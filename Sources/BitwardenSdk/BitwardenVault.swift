// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(BitwardenVaultFFI)
import BitwardenVaultFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bitwarden_vault_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bitwarden_vault_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt32: FfiConverterPrimitive {
    typealias FfiType = UInt32
    typealias SwiftType = UInt32

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt32 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterData: FfiConverterRustBuffer {
    typealias SwiftType = Data

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Data {
        let len: Int32 = try readInt(&buf)
        return Data(try readBytes(&buf, count: Int(len)))
    }

    public static func write(_ value: Data, into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        writeBytes(&buf, value)
    }
}


public struct Attachment {
    public let id: String?
    public let url: String?
    public let size: String?
    /**
     * Readable size, ex: "4.2 KB" or "1.43 GB"
     */
    public let sizeName: String?
    public let fileName: EncString?
    public let key: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String?, url: String?, size: String?, 
        /**
         * Readable size, ex: "4.2 KB" or "1.43 GB"
         */sizeName: String?, fileName: EncString?, key: EncString?) {
        self.id = id
        self.url = url
        self.size = size
        self.sizeName = sizeName
        self.fileName = fileName
        self.key = key
    }
}



extension Attachment: Equatable, Hashable {
    public static func ==(lhs: Attachment, rhs: Attachment) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.sizeName != rhs.sizeName {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(url)
        hasher.combine(size)
        hasher.combine(sizeName)
        hasher.combine(fileName)
        hasher.combine(key)
    }
}


public struct FfiConverterTypeAttachment: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Attachment {
        return
            try Attachment(
                id: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionString.read(from: &buf), 
                sizeName: FfiConverterOptionString.read(from: &buf), 
                fileName: FfiConverterOptionTypeEncString.read(from: &buf), 
                key: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: Attachment, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.size, into: &buf)
        FfiConverterOptionString.write(value.sizeName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.fileName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.key, into: &buf)
    }
}


public func FfiConverterTypeAttachment_lift(_ buf: RustBuffer) throws -> Attachment {
    return try FfiConverterTypeAttachment.lift(buf)
}

public func FfiConverterTypeAttachment_lower(_ value: Attachment) -> RustBuffer {
    return FfiConverterTypeAttachment.lower(value)
}


public struct AttachmentEncryptResult {
    public let attachment: Attachment
    public let contents: Data

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(attachment: Attachment, contents: Data) {
        self.attachment = attachment
        self.contents = contents
    }
}



extension AttachmentEncryptResult: Equatable, Hashable {
    public static func ==(lhs: AttachmentEncryptResult, rhs: AttachmentEncryptResult) -> Bool {
        if lhs.attachment != rhs.attachment {
            return false
        }
        if lhs.contents != rhs.contents {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(attachment)
        hasher.combine(contents)
    }
}


public struct FfiConverterTypeAttachmentEncryptResult: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentEncryptResult {
        return
            try AttachmentEncryptResult(
                attachment: FfiConverterTypeAttachment.read(from: &buf), 
                contents: FfiConverterData.read(from: &buf)
        )
    }

    public static func write(_ value: AttachmentEncryptResult, into buf: inout [UInt8]) {
        FfiConverterTypeAttachment.write(value.attachment, into: &buf)
        FfiConverterData.write(value.contents, into: &buf)
    }
}


public func FfiConverterTypeAttachmentEncryptResult_lift(_ buf: RustBuffer) throws -> AttachmentEncryptResult {
    return try FfiConverterTypeAttachmentEncryptResult.lift(buf)
}

public func FfiConverterTypeAttachmentEncryptResult_lower(_ value: AttachmentEncryptResult) -> RustBuffer {
    return FfiConverterTypeAttachmentEncryptResult.lower(value)
}


public struct AttachmentView {
    public let id: String?
    public let url: String?
    public let size: String?
    public let sizeName: String?
    public let fileName: String?
    public let key: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: String?, url: String?, size: String?, sizeName: String?, fileName: String?, key: EncString?) {
        self.id = id
        self.url = url
        self.size = size
        self.sizeName = sizeName
        self.fileName = fileName
        self.key = key
    }
}



extension AttachmentView: Equatable, Hashable {
    public static func ==(lhs: AttachmentView, rhs: AttachmentView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.url != rhs.url {
            return false
        }
        if lhs.size != rhs.size {
            return false
        }
        if lhs.sizeName != rhs.sizeName {
            return false
        }
        if lhs.fileName != rhs.fileName {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(url)
        hasher.combine(size)
        hasher.combine(sizeName)
        hasher.combine(fileName)
        hasher.combine(key)
    }
}


public struct FfiConverterTypeAttachmentView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AttachmentView {
        return
            try AttachmentView(
                id: FfiConverterOptionString.read(from: &buf), 
                url: FfiConverterOptionString.read(from: &buf), 
                size: FfiConverterOptionString.read(from: &buf), 
                sizeName: FfiConverterOptionString.read(from: &buf), 
                fileName: FfiConverterOptionString.read(from: &buf), 
                key: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: AttachmentView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.id, into: &buf)
        FfiConverterOptionString.write(value.url, into: &buf)
        FfiConverterOptionString.write(value.size, into: &buf)
        FfiConverterOptionString.write(value.sizeName, into: &buf)
        FfiConverterOptionString.write(value.fileName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.key, into: &buf)
    }
}


public func FfiConverterTypeAttachmentView_lift(_ buf: RustBuffer) throws -> AttachmentView {
    return try FfiConverterTypeAttachmentView.lift(buf)
}

public func FfiConverterTypeAttachmentView_lower(_ value: AttachmentView) -> RustBuffer {
    return FfiConverterTypeAttachmentView.lower(value)
}


public struct Card {
    public let cardholderName: EncString?
    public let expMonth: EncString?
    public let expYear: EncString?
    public let code: EncString?
    public let brand: EncString?
    public let number: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cardholderName: EncString?, expMonth: EncString?, expYear: EncString?, code: EncString?, brand: EncString?, number: EncString?) {
        self.cardholderName = cardholderName
        self.expMonth = expMonth
        self.expYear = expYear
        self.code = code
        self.brand = brand
        self.number = number
    }
}



extension Card: Equatable, Hashable {
    public static func ==(lhs: Card, rhs: Card) -> Bool {
        if lhs.cardholderName != rhs.cardholderName {
            return false
        }
        if lhs.expMonth != rhs.expMonth {
            return false
        }
        if lhs.expYear != rhs.expYear {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.brand != rhs.brand {
            return false
        }
        if lhs.number != rhs.number {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cardholderName)
        hasher.combine(expMonth)
        hasher.combine(expYear)
        hasher.combine(code)
        hasher.combine(brand)
        hasher.combine(number)
    }
}


public struct FfiConverterTypeCard: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Card {
        return
            try Card(
                cardholderName: FfiConverterOptionTypeEncString.read(from: &buf), 
                expMonth: FfiConverterOptionTypeEncString.read(from: &buf), 
                expYear: FfiConverterOptionTypeEncString.read(from: &buf), 
                code: FfiConverterOptionTypeEncString.read(from: &buf), 
                brand: FfiConverterOptionTypeEncString.read(from: &buf), 
                number: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: Card, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.cardholderName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.expMonth, into: &buf)
        FfiConverterOptionTypeEncString.write(value.expYear, into: &buf)
        FfiConverterOptionTypeEncString.write(value.code, into: &buf)
        FfiConverterOptionTypeEncString.write(value.brand, into: &buf)
        FfiConverterOptionTypeEncString.write(value.number, into: &buf)
    }
}


public func FfiConverterTypeCard_lift(_ buf: RustBuffer) throws -> Card {
    return try FfiConverterTypeCard.lift(buf)
}

public func FfiConverterTypeCard_lower(_ value: Card) -> RustBuffer {
    return FfiConverterTypeCard.lower(value)
}


public struct CardView {
    public let cardholderName: String?
    public let expMonth: String?
    public let expYear: String?
    public let code: String?
    public let brand: String?
    public let number: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(cardholderName: String?, expMonth: String?, expYear: String?, code: String?, brand: String?, number: String?) {
        self.cardholderName = cardholderName
        self.expMonth = expMonth
        self.expYear = expYear
        self.code = code
        self.brand = brand
        self.number = number
    }
}



extension CardView: Equatable, Hashable {
    public static func ==(lhs: CardView, rhs: CardView) -> Bool {
        if lhs.cardholderName != rhs.cardholderName {
            return false
        }
        if lhs.expMonth != rhs.expMonth {
            return false
        }
        if lhs.expYear != rhs.expYear {
            return false
        }
        if lhs.code != rhs.code {
            return false
        }
        if lhs.brand != rhs.brand {
            return false
        }
        if lhs.number != rhs.number {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(cardholderName)
        hasher.combine(expMonth)
        hasher.combine(expYear)
        hasher.combine(code)
        hasher.combine(brand)
        hasher.combine(number)
    }
}


public struct FfiConverterTypeCardView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CardView {
        return
            try CardView(
                cardholderName: FfiConverterOptionString.read(from: &buf), 
                expMonth: FfiConverterOptionString.read(from: &buf), 
                expYear: FfiConverterOptionString.read(from: &buf), 
                code: FfiConverterOptionString.read(from: &buf), 
                brand: FfiConverterOptionString.read(from: &buf), 
                number: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: CardView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.cardholderName, into: &buf)
        FfiConverterOptionString.write(value.expMonth, into: &buf)
        FfiConverterOptionString.write(value.expYear, into: &buf)
        FfiConverterOptionString.write(value.code, into: &buf)
        FfiConverterOptionString.write(value.brand, into: &buf)
        FfiConverterOptionString.write(value.number, into: &buf)
    }
}


public func FfiConverterTypeCardView_lift(_ buf: RustBuffer) throws -> CardView {
    return try FfiConverterTypeCardView.lift(buf)
}

public func FfiConverterTypeCardView_lower(_ value: CardView) -> RustBuffer {
    return FfiConverterTypeCardView.lower(value)
}


public struct Cipher {
    public let id: Uuid?
    public let organizationId: Uuid?
    public let folderId: Uuid?
    public let collectionIds: [Uuid]
    /**
     * More recent ciphers uses individual encryption keys to encrypt the other fields of the
     * Cipher.
     */
    public let key: EncString?
    public let name: EncString
    public let notes: EncString?
    public let type: CipherType
    public let login: Login?
    public let identity: Identity?
    public let card: Card?
    public let secureNote: SecureNote?
    public let sshKey: SshKey?
    public let favorite: Bool
    public let reprompt: CipherRepromptType
    public let organizationUseTotp: Bool
    public let edit: Bool
    public let viewPassword: Bool
    public let localData: LocalData?
    public let attachments: [Attachment]?
    public let fields: [Field]?
    public let passwordHistory: [PasswordHistory]?
    public let creationDate: DateTime
    public let deletedDate: DateTime?
    public let revisionDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Uuid?, organizationId: Uuid?, folderId: Uuid?, collectionIds: [Uuid], 
        /**
         * More recent ciphers uses individual encryption keys to encrypt the other fields of the
         * Cipher.
         */key: EncString?, name: EncString, notes: EncString?, type: CipherType, login: Login?, identity: Identity?, card: Card?, secureNote: SecureNote?, sshKey: SshKey?, favorite: Bool, reprompt: CipherRepromptType, organizationUseTotp: Bool, edit: Bool, viewPassword: Bool, localData: LocalData?, attachments: [Attachment]?, fields: [Field]?, passwordHistory: [PasswordHistory]?, creationDate: DateTime, deletedDate: DateTime?, revisionDate: DateTime) {
        self.id = id
        self.organizationId = organizationId
        self.folderId = folderId
        self.collectionIds = collectionIds
        self.key = key
        self.name = name
        self.notes = notes
        self.type = type
        self.login = login
        self.identity = identity
        self.card = card
        self.secureNote = secureNote
        self.sshKey = sshKey
        self.favorite = favorite
        self.reprompt = reprompt
        self.organizationUseTotp = organizationUseTotp
        self.edit = edit
        self.viewPassword = viewPassword
        self.localData = localData
        self.attachments = attachments
        self.fields = fields
        self.passwordHistory = passwordHistory
        self.creationDate = creationDate
        self.deletedDate = deletedDate
        self.revisionDate = revisionDate
    }
}



extension Cipher: Equatable, Hashable {
    public static func ==(lhs: Cipher, rhs: Cipher) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.organizationId != rhs.organizationId {
            return false
        }
        if lhs.folderId != rhs.folderId {
            return false
        }
        if lhs.collectionIds != rhs.collectionIds {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.notes != rhs.notes {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.login != rhs.login {
            return false
        }
        if lhs.identity != rhs.identity {
            return false
        }
        if lhs.card != rhs.card {
            return false
        }
        if lhs.secureNote != rhs.secureNote {
            return false
        }
        if lhs.sshKey != rhs.sshKey {
            return false
        }
        if lhs.favorite != rhs.favorite {
            return false
        }
        if lhs.reprompt != rhs.reprompt {
            return false
        }
        if lhs.organizationUseTotp != rhs.organizationUseTotp {
            return false
        }
        if lhs.edit != rhs.edit {
            return false
        }
        if lhs.viewPassword != rhs.viewPassword {
            return false
        }
        if lhs.localData != rhs.localData {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        if lhs.fields != rhs.fields {
            return false
        }
        if lhs.passwordHistory != rhs.passwordHistory {
            return false
        }
        if lhs.creationDate != rhs.creationDate {
            return false
        }
        if lhs.deletedDate != rhs.deletedDate {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(organizationId)
        hasher.combine(folderId)
        hasher.combine(collectionIds)
        hasher.combine(key)
        hasher.combine(name)
        hasher.combine(notes)
        hasher.combine(type)
        hasher.combine(login)
        hasher.combine(identity)
        hasher.combine(card)
        hasher.combine(secureNote)
        hasher.combine(sshKey)
        hasher.combine(favorite)
        hasher.combine(reprompt)
        hasher.combine(organizationUseTotp)
        hasher.combine(edit)
        hasher.combine(viewPassword)
        hasher.combine(localData)
        hasher.combine(attachments)
        hasher.combine(fields)
        hasher.combine(passwordHistory)
        hasher.combine(creationDate)
        hasher.combine(deletedDate)
        hasher.combine(revisionDate)
    }
}


public struct FfiConverterTypeCipher: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Cipher {
        return
            try Cipher(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                organizationId: FfiConverterOptionTypeUuid.read(from: &buf), 
                folderId: FfiConverterOptionTypeUuid.read(from: &buf), 
                collectionIds: FfiConverterSequenceTypeUuid.read(from: &buf), 
                key: FfiConverterOptionTypeEncString.read(from: &buf), 
                name: FfiConverterTypeEncString.read(from: &buf), 
                notes: FfiConverterOptionTypeEncString.read(from: &buf), 
                type: FfiConverterTypeCipherType.read(from: &buf), 
                login: FfiConverterOptionTypeLogin.read(from: &buf), 
                identity: FfiConverterOptionTypeIdentity.read(from: &buf), 
                card: FfiConverterOptionTypeCard.read(from: &buf), 
                secureNote: FfiConverterOptionTypeSecureNote.read(from: &buf), 
                sshKey: FfiConverterOptionTypeSshKey.read(from: &buf), 
                favorite: FfiConverterBool.read(from: &buf), 
                reprompt: FfiConverterTypeCipherRepromptType.read(from: &buf), 
                organizationUseTotp: FfiConverterBool.read(from: &buf), 
                edit: FfiConverterBool.read(from: &buf), 
                viewPassword: FfiConverterBool.read(from: &buf), 
                localData: FfiConverterOptionTypeLocalData.read(from: &buf), 
                attachments: FfiConverterOptionSequenceTypeAttachment.read(from: &buf), 
                fields: FfiConverterOptionSequenceTypeField.read(from: &buf), 
                passwordHistory: FfiConverterOptionSequenceTypePasswordHistory.read(from: &buf), 
                creationDate: FfiConverterTypeDateTime.read(from: &buf), 
                deletedDate: FfiConverterOptionTypeDateTime.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Cipher, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterOptionTypeUuid.write(value.organizationId, into: &buf)
        FfiConverterOptionTypeUuid.write(value.folderId, into: &buf)
        FfiConverterSequenceTypeUuid.write(value.collectionIds, into: &buf)
        FfiConverterOptionTypeEncString.write(value.key, into: &buf)
        FfiConverterTypeEncString.write(value.name, into: &buf)
        FfiConverterOptionTypeEncString.write(value.notes, into: &buf)
        FfiConverterTypeCipherType.write(value.type, into: &buf)
        FfiConverterOptionTypeLogin.write(value.login, into: &buf)
        FfiConverterOptionTypeIdentity.write(value.identity, into: &buf)
        FfiConverterOptionTypeCard.write(value.card, into: &buf)
        FfiConverterOptionTypeSecureNote.write(value.secureNote, into: &buf)
        FfiConverterOptionTypeSshKey.write(value.sshKey, into: &buf)
        FfiConverterBool.write(value.favorite, into: &buf)
        FfiConverterTypeCipherRepromptType.write(value.reprompt, into: &buf)
        FfiConverterBool.write(value.organizationUseTotp, into: &buf)
        FfiConverterBool.write(value.edit, into: &buf)
        FfiConverterBool.write(value.viewPassword, into: &buf)
        FfiConverterOptionTypeLocalData.write(value.localData, into: &buf)
        FfiConverterOptionSequenceTypeAttachment.write(value.attachments, into: &buf)
        FfiConverterOptionSequenceTypeField.write(value.fields, into: &buf)
        FfiConverterOptionSequenceTypePasswordHistory.write(value.passwordHistory, into: &buf)
        FfiConverterTypeDateTime.write(value.creationDate, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.deletedDate, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
    }
}


public func FfiConverterTypeCipher_lift(_ buf: RustBuffer) throws -> Cipher {
    return try FfiConverterTypeCipher.lift(buf)
}

public func FfiConverterTypeCipher_lower(_ value: Cipher) -> RustBuffer {
    return FfiConverterTypeCipher.lower(value)
}


public struct CipherListView {
    public let id: Uuid?
    public let organizationId: Uuid?
    public let folderId: Uuid?
    public let collectionIds: [Uuid]
    /**
     * Temporary, required to support calculating TOTP from CipherListView.
     */
    public let key: EncString?
    public let name: String
    public let subTitle: String
    public let type: CipherListViewType
    public let favorite: Bool
    public let reprompt: CipherRepromptType
    public let edit: Bool
    public let viewPassword: Bool
    /**
     * The number of attachments
     */
    public let attachments: UInt32
    public let creationDate: DateTime
    public let deletedDate: DateTime?
    public let revisionDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Uuid?, organizationId: Uuid?, folderId: Uuid?, collectionIds: [Uuid], 
        /**
         * Temporary, required to support calculating TOTP from CipherListView.
         */key: EncString?, name: String, subTitle: String, type: CipherListViewType, favorite: Bool, reprompt: CipherRepromptType, edit: Bool, viewPassword: Bool, 
        /**
         * The number of attachments
         */attachments: UInt32, creationDate: DateTime, deletedDate: DateTime?, revisionDate: DateTime) {
        self.id = id
        self.organizationId = organizationId
        self.folderId = folderId
        self.collectionIds = collectionIds
        self.key = key
        self.name = name
        self.subTitle = subTitle
        self.type = type
        self.favorite = favorite
        self.reprompt = reprompt
        self.edit = edit
        self.viewPassword = viewPassword
        self.attachments = attachments
        self.creationDate = creationDate
        self.deletedDate = deletedDate
        self.revisionDate = revisionDate
    }
}



extension CipherListView: Equatable, Hashable {
    public static func ==(lhs: CipherListView, rhs: CipherListView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.organizationId != rhs.organizationId {
            return false
        }
        if lhs.folderId != rhs.folderId {
            return false
        }
        if lhs.collectionIds != rhs.collectionIds {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.subTitle != rhs.subTitle {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.favorite != rhs.favorite {
            return false
        }
        if lhs.reprompt != rhs.reprompt {
            return false
        }
        if lhs.edit != rhs.edit {
            return false
        }
        if lhs.viewPassword != rhs.viewPassword {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        if lhs.creationDate != rhs.creationDate {
            return false
        }
        if lhs.deletedDate != rhs.deletedDate {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(organizationId)
        hasher.combine(folderId)
        hasher.combine(collectionIds)
        hasher.combine(key)
        hasher.combine(name)
        hasher.combine(subTitle)
        hasher.combine(type)
        hasher.combine(favorite)
        hasher.combine(reprompt)
        hasher.combine(edit)
        hasher.combine(viewPassword)
        hasher.combine(attachments)
        hasher.combine(creationDate)
        hasher.combine(deletedDate)
        hasher.combine(revisionDate)
    }
}


public struct FfiConverterTypeCipherListView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherListView {
        return
            try CipherListView(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                organizationId: FfiConverterOptionTypeUuid.read(from: &buf), 
                folderId: FfiConverterOptionTypeUuid.read(from: &buf), 
                collectionIds: FfiConverterSequenceTypeUuid.read(from: &buf), 
                key: FfiConverterOptionTypeEncString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                subTitle: FfiConverterString.read(from: &buf), 
                type: FfiConverterTypeCipherListViewType.read(from: &buf), 
                favorite: FfiConverterBool.read(from: &buf), 
                reprompt: FfiConverterTypeCipherRepromptType.read(from: &buf), 
                edit: FfiConverterBool.read(from: &buf), 
                viewPassword: FfiConverterBool.read(from: &buf), 
                attachments: FfiConverterUInt32.read(from: &buf), 
                creationDate: FfiConverterTypeDateTime.read(from: &buf), 
                deletedDate: FfiConverterOptionTypeDateTime.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: CipherListView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterOptionTypeUuid.write(value.organizationId, into: &buf)
        FfiConverterOptionTypeUuid.write(value.folderId, into: &buf)
        FfiConverterSequenceTypeUuid.write(value.collectionIds, into: &buf)
        FfiConverterOptionTypeEncString.write(value.key, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterString.write(value.subTitle, into: &buf)
        FfiConverterTypeCipherListViewType.write(value.type, into: &buf)
        FfiConverterBool.write(value.favorite, into: &buf)
        FfiConverterTypeCipherRepromptType.write(value.reprompt, into: &buf)
        FfiConverterBool.write(value.edit, into: &buf)
        FfiConverterBool.write(value.viewPassword, into: &buf)
        FfiConverterUInt32.write(value.attachments, into: &buf)
        FfiConverterTypeDateTime.write(value.creationDate, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.deletedDate, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
    }
}


public func FfiConverterTypeCipherListView_lift(_ buf: RustBuffer) throws -> CipherListView {
    return try FfiConverterTypeCipherListView.lift(buf)
}

public func FfiConverterTypeCipherListView_lower(_ value: CipherListView) -> RustBuffer {
    return FfiConverterTypeCipherListView.lower(value)
}


public struct CipherView {
    public let id: Uuid?
    public let organizationId: Uuid?
    public let folderId: Uuid?
    public let collectionIds: [Uuid]
    /**
     * Temporary, required to support re-encrypting existing items.
     */
    public let key: EncString?
    public let name: String
    public let notes: String?
    public let type: CipherType
    public let login: LoginView?
    public let identity: IdentityView?
    public let card: CardView?
    public let secureNote: SecureNoteView?
    public let sshKey: SshKeyView?
    public let favorite: Bool
    public let reprompt: CipherRepromptType
    public let organizationUseTotp: Bool
    public let edit: Bool
    public let viewPassword: Bool
    public let localData: LocalDataView?
    public let attachments: [AttachmentView]?
    public let fields: [FieldView]?
    public let passwordHistory: [PasswordHistoryView]?
    public let creationDate: DateTime
    public let deletedDate: DateTime?
    public let revisionDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Uuid?, organizationId: Uuid?, folderId: Uuid?, collectionIds: [Uuid], 
        /**
         * Temporary, required to support re-encrypting existing items.
         */key: EncString?, name: String, notes: String?, type: CipherType, login: LoginView?, identity: IdentityView?, card: CardView?, secureNote: SecureNoteView?, sshKey: SshKeyView?, favorite: Bool, reprompt: CipherRepromptType, organizationUseTotp: Bool, edit: Bool, viewPassword: Bool, localData: LocalDataView?, attachments: [AttachmentView]?, fields: [FieldView]?, passwordHistory: [PasswordHistoryView]?, creationDate: DateTime, deletedDate: DateTime?, revisionDate: DateTime) {
        self.id = id
        self.organizationId = organizationId
        self.folderId = folderId
        self.collectionIds = collectionIds
        self.key = key
        self.name = name
        self.notes = notes
        self.type = type
        self.login = login
        self.identity = identity
        self.card = card
        self.secureNote = secureNote
        self.sshKey = sshKey
        self.favorite = favorite
        self.reprompt = reprompt
        self.organizationUseTotp = organizationUseTotp
        self.edit = edit
        self.viewPassword = viewPassword
        self.localData = localData
        self.attachments = attachments
        self.fields = fields
        self.passwordHistory = passwordHistory
        self.creationDate = creationDate
        self.deletedDate = deletedDate
        self.revisionDate = revisionDate
    }
}



extension CipherView: Equatable, Hashable {
    public static func ==(lhs: CipherView, rhs: CipherView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.organizationId != rhs.organizationId {
            return false
        }
        if lhs.folderId != rhs.folderId {
            return false
        }
        if lhs.collectionIds != rhs.collectionIds {
            return false
        }
        if lhs.key != rhs.key {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.notes != rhs.notes {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.login != rhs.login {
            return false
        }
        if lhs.identity != rhs.identity {
            return false
        }
        if lhs.card != rhs.card {
            return false
        }
        if lhs.secureNote != rhs.secureNote {
            return false
        }
        if lhs.sshKey != rhs.sshKey {
            return false
        }
        if lhs.favorite != rhs.favorite {
            return false
        }
        if lhs.reprompt != rhs.reprompt {
            return false
        }
        if lhs.organizationUseTotp != rhs.organizationUseTotp {
            return false
        }
        if lhs.edit != rhs.edit {
            return false
        }
        if lhs.viewPassword != rhs.viewPassword {
            return false
        }
        if lhs.localData != rhs.localData {
            return false
        }
        if lhs.attachments != rhs.attachments {
            return false
        }
        if lhs.fields != rhs.fields {
            return false
        }
        if lhs.passwordHistory != rhs.passwordHistory {
            return false
        }
        if lhs.creationDate != rhs.creationDate {
            return false
        }
        if lhs.deletedDate != rhs.deletedDate {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(organizationId)
        hasher.combine(folderId)
        hasher.combine(collectionIds)
        hasher.combine(key)
        hasher.combine(name)
        hasher.combine(notes)
        hasher.combine(type)
        hasher.combine(login)
        hasher.combine(identity)
        hasher.combine(card)
        hasher.combine(secureNote)
        hasher.combine(sshKey)
        hasher.combine(favorite)
        hasher.combine(reprompt)
        hasher.combine(organizationUseTotp)
        hasher.combine(edit)
        hasher.combine(viewPassword)
        hasher.combine(localData)
        hasher.combine(attachments)
        hasher.combine(fields)
        hasher.combine(passwordHistory)
        hasher.combine(creationDate)
        hasher.combine(deletedDate)
        hasher.combine(revisionDate)
    }
}


public struct FfiConverterTypeCipherView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherView {
        return
            try CipherView(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                organizationId: FfiConverterOptionTypeUuid.read(from: &buf), 
                folderId: FfiConverterOptionTypeUuid.read(from: &buf), 
                collectionIds: FfiConverterSequenceTypeUuid.read(from: &buf), 
                key: FfiConverterOptionTypeEncString.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                notes: FfiConverterOptionString.read(from: &buf), 
                type: FfiConverterTypeCipherType.read(from: &buf), 
                login: FfiConverterOptionTypeLoginView.read(from: &buf), 
                identity: FfiConverterOptionTypeIdentityView.read(from: &buf), 
                card: FfiConverterOptionTypeCardView.read(from: &buf), 
                secureNote: FfiConverterOptionTypeSecureNoteView.read(from: &buf), 
                sshKey: FfiConverterOptionTypeSshKeyView.read(from: &buf), 
                favorite: FfiConverterBool.read(from: &buf), 
                reprompt: FfiConverterTypeCipherRepromptType.read(from: &buf), 
                organizationUseTotp: FfiConverterBool.read(from: &buf), 
                edit: FfiConverterBool.read(from: &buf), 
                viewPassword: FfiConverterBool.read(from: &buf), 
                localData: FfiConverterOptionTypeLocalDataView.read(from: &buf), 
                attachments: FfiConverterOptionSequenceTypeAttachmentView.read(from: &buf), 
                fields: FfiConverterOptionSequenceTypeFieldView.read(from: &buf), 
                passwordHistory: FfiConverterOptionSequenceTypePasswordHistoryView.read(from: &buf), 
                creationDate: FfiConverterTypeDateTime.read(from: &buf), 
                deletedDate: FfiConverterOptionTypeDateTime.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: CipherView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterOptionTypeUuid.write(value.organizationId, into: &buf)
        FfiConverterOptionTypeUuid.write(value.folderId, into: &buf)
        FfiConverterSequenceTypeUuid.write(value.collectionIds, into: &buf)
        FfiConverterOptionTypeEncString.write(value.key, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.notes, into: &buf)
        FfiConverterTypeCipherType.write(value.type, into: &buf)
        FfiConverterOptionTypeLoginView.write(value.login, into: &buf)
        FfiConverterOptionTypeIdentityView.write(value.identity, into: &buf)
        FfiConverterOptionTypeCardView.write(value.card, into: &buf)
        FfiConverterOptionTypeSecureNoteView.write(value.secureNote, into: &buf)
        FfiConverterOptionTypeSshKeyView.write(value.sshKey, into: &buf)
        FfiConverterBool.write(value.favorite, into: &buf)
        FfiConverterTypeCipherRepromptType.write(value.reprompt, into: &buf)
        FfiConverterBool.write(value.organizationUseTotp, into: &buf)
        FfiConverterBool.write(value.edit, into: &buf)
        FfiConverterBool.write(value.viewPassword, into: &buf)
        FfiConverterOptionTypeLocalDataView.write(value.localData, into: &buf)
        FfiConverterOptionSequenceTypeAttachmentView.write(value.attachments, into: &buf)
        FfiConverterOptionSequenceTypeFieldView.write(value.fields, into: &buf)
        FfiConverterOptionSequenceTypePasswordHistoryView.write(value.passwordHistory, into: &buf)
        FfiConverterTypeDateTime.write(value.creationDate, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.deletedDate, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
    }
}


public func FfiConverterTypeCipherView_lift(_ buf: RustBuffer) throws -> CipherView {
    return try FfiConverterTypeCipherView.lift(buf)
}

public func FfiConverterTypeCipherView_lower(_ value: CipherView) -> RustBuffer {
    return FfiConverterTypeCipherView.lower(value)
}


public struct Collection {
    public let id: Uuid?
    public let organizationId: Uuid
    public let name: EncString
    public let externalId: String?
    public let hidePasswords: Bool
    public let readOnly: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Uuid?, organizationId: Uuid, name: EncString, externalId: String?, hidePasswords: Bool, readOnly: Bool) {
        self.id = id
        self.organizationId = organizationId
        self.name = name
        self.externalId = externalId
        self.hidePasswords = hidePasswords
        self.readOnly = readOnly
    }
}



extension Collection: Equatable, Hashable {
    public static func ==(lhs: Collection, rhs: Collection) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.organizationId != rhs.organizationId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.externalId != rhs.externalId {
            return false
        }
        if lhs.hidePasswords != rhs.hidePasswords {
            return false
        }
        if lhs.readOnly != rhs.readOnly {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(organizationId)
        hasher.combine(name)
        hasher.combine(externalId)
        hasher.combine(hidePasswords)
        hasher.combine(readOnly)
    }
}


public struct FfiConverterTypeCollection: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Collection {
        return
            try Collection(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                organizationId: FfiConverterTypeUuid.read(from: &buf), 
                name: FfiConverterTypeEncString.read(from: &buf), 
                externalId: FfiConverterOptionString.read(from: &buf), 
                hidePasswords: FfiConverterBool.read(from: &buf), 
                readOnly: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: Collection, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeUuid.write(value.organizationId, into: &buf)
        FfiConverterTypeEncString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.externalId, into: &buf)
        FfiConverterBool.write(value.hidePasswords, into: &buf)
        FfiConverterBool.write(value.readOnly, into: &buf)
    }
}


public func FfiConverterTypeCollection_lift(_ buf: RustBuffer) throws -> Collection {
    return try FfiConverterTypeCollection.lift(buf)
}

public func FfiConverterTypeCollection_lower(_ value: Collection) -> RustBuffer {
    return FfiConverterTypeCollection.lower(value)
}


public struct CollectionView {
    public let id: Uuid?
    public let organizationId: Uuid
    public let name: String
    public let externalId: String?
    public let hidePasswords: Bool
    public let readOnly: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Uuid?, organizationId: Uuid, name: String, externalId: String?, hidePasswords: Bool, readOnly: Bool) {
        self.id = id
        self.organizationId = organizationId
        self.name = name
        self.externalId = externalId
        self.hidePasswords = hidePasswords
        self.readOnly = readOnly
    }
}



extension CollectionView: Equatable, Hashable {
    public static func ==(lhs: CollectionView, rhs: CollectionView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.organizationId != rhs.organizationId {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.externalId != rhs.externalId {
            return false
        }
        if lhs.hidePasswords != rhs.hidePasswords {
            return false
        }
        if lhs.readOnly != rhs.readOnly {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(organizationId)
        hasher.combine(name)
        hasher.combine(externalId)
        hasher.combine(hidePasswords)
        hasher.combine(readOnly)
    }
}


public struct FfiConverterTypeCollectionView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CollectionView {
        return
            try CollectionView(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                organizationId: FfiConverterTypeUuid.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                externalId: FfiConverterOptionString.read(from: &buf), 
                hidePasswords: FfiConverterBool.read(from: &buf), 
                readOnly: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: CollectionView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeUuid.write(value.organizationId, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.externalId, into: &buf)
        FfiConverterBool.write(value.hidePasswords, into: &buf)
        FfiConverterBool.write(value.readOnly, into: &buf)
    }
}


public func FfiConverterTypeCollectionView_lift(_ buf: RustBuffer) throws -> CollectionView {
    return try FfiConverterTypeCollectionView.lift(buf)
}

public func FfiConverterTypeCollectionView_lower(_ value: CollectionView) -> RustBuffer {
    return FfiConverterTypeCollectionView.lower(value)
}


public struct Fido2Credential {
    public let credentialId: EncString
    public let keyType: EncString
    public let keyAlgorithm: EncString
    public let keyCurve: EncString
    public let keyValue: EncString
    public let rpId: EncString
    public let userHandle: EncString?
    public let userName: EncString?
    public let counter: EncString
    public let rpName: EncString?
    public let userDisplayName: EncString?
    public let discoverable: EncString
    public let creationDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(credentialId: EncString, keyType: EncString, keyAlgorithm: EncString, keyCurve: EncString, keyValue: EncString, rpId: EncString, userHandle: EncString?, userName: EncString?, counter: EncString, rpName: EncString?, userDisplayName: EncString?, discoverable: EncString, creationDate: DateTime) {
        self.credentialId = credentialId
        self.keyType = keyType
        self.keyAlgorithm = keyAlgorithm
        self.keyCurve = keyCurve
        self.keyValue = keyValue
        self.rpId = rpId
        self.userHandle = userHandle
        self.userName = userName
        self.counter = counter
        self.rpName = rpName
        self.userDisplayName = userDisplayName
        self.discoverable = discoverable
        self.creationDate = creationDate
    }
}



extension Fido2Credential: Equatable, Hashable {
    public static func ==(lhs: Fido2Credential, rhs: Fido2Credential) -> Bool {
        if lhs.credentialId != rhs.credentialId {
            return false
        }
        if lhs.keyType != rhs.keyType {
            return false
        }
        if lhs.keyAlgorithm != rhs.keyAlgorithm {
            return false
        }
        if lhs.keyCurve != rhs.keyCurve {
            return false
        }
        if lhs.keyValue != rhs.keyValue {
            return false
        }
        if lhs.rpId != rhs.rpId {
            return false
        }
        if lhs.userHandle != rhs.userHandle {
            return false
        }
        if lhs.userName != rhs.userName {
            return false
        }
        if lhs.counter != rhs.counter {
            return false
        }
        if lhs.rpName != rhs.rpName {
            return false
        }
        if lhs.userDisplayName != rhs.userDisplayName {
            return false
        }
        if lhs.discoverable != rhs.discoverable {
            return false
        }
        if lhs.creationDate != rhs.creationDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(credentialId)
        hasher.combine(keyType)
        hasher.combine(keyAlgorithm)
        hasher.combine(keyCurve)
        hasher.combine(keyValue)
        hasher.combine(rpId)
        hasher.combine(userHandle)
        hasher.combine(userName)
        hasher.combine(counter)
        hasher.combine(rpName)
        hasher.combine(userDisplayName)
        hasher.combine(discoverable)
        hasher.combine(creationDate)
    }
}


public struct FfiConverterTypeFido2Credential: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fido2Credential {
        return
            try Fido2Credential(
                credentialId: FfiConverterTypeEncString.read(from: &buf), 
                keyType: FfiConverterTypeEncString.read(from: &buf), 
                keyAlgorithm: FfiConverterTypeEncString.read(from: &buf), 
                keyCurve: FfiConverterTypeEncString.read(from: &buf), 
                keyValue: FfiConverterTypeEncString.read(from: &buf), 
                rpId: FfiConverterTypeEncString.read(from: &buf), 
                userHandle: FfiConverterOptionTypeEncString.read(from: &buf), 
                userName: FfiConverterOptionTypeEncString.read(from: &buf), 
                counter: FfiConverterTypeEncString.read(from: &buf), 
                rpName: FfiConverterOptionTypeEncString.read(from: &buf), 
                userDisplayName: FfiConverterOptionTypeEncString.read(from: &buf), 
                discoverable: FfiConverterTypeEncString.read(from: &buf), 
                creationDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Fido2Credential, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.credentialId, into: &buf)
        FfiConverterTypeEncString.write(value.keyType, into: &buf)
        FfiConverterTypeEncString.write(value.keyAlgorithm, into: &buf)
        FfiConverterTypeEncString.write(value.keyCurve, into: &buf)
        FfiConverterTypeEncString.write(value.keyValue, into: &buf)
        FfiConverterTypeEncString.write(value.rpId, into: &buf)
        FfiConverterOptionTypeEncString.write(value.userHandle, into: &buf)
        FfiConverterOptionTypeEncString.write(value.userName, into: &buf)
        FfiConverterTypeEncString.write(value.counter, into: &buf)
        FfiConverterOptionTypeEncString.write(value.rpName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.userDisplayName, into: &buf)
        FfiConverterTypeEncString.write(value.discoverable, into: &buf)
        FfiConverterTypeDateTime.write(value.creationDate, into: &buf)
    }
}


public func FfiConverterTypeFido2Credential_lift(_ buf: RustBuffer) throws -> Fido2Credential {
    return try FfiConverterTypeFido2Credential.lift(buf)
}

public func FfiConverterTypeFido2Credential_lower(_ value: Fido2Credential) -> RustBuffer {
    return FfiConverterTypeFido2Credential.lower(value)
}


public struct Fido2CredentialNewView {
    public let credentialId: String
    public let keyType: String
    public let keyAlgorithm: String
    public let keyCurve: String
    public let rpId: String
    public let userHandle: String?
    public let userName: String?
    public let counter: String
    public let rpName: String?
    public let userDisplayName: String?
    public let creationDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(credentialId: String, keyType: String, keyAlgorithm: String, keyCurve: String, rpId: String, userHandle: String?, userName: String?, counter: String, rpName: String?, userDisplayName: String?, creationDate: DateTime) {
        self.credentialId = credentialId
        self.keyType = keyType
        self.keyAlgorithm = keyAlgorithm
        self.keyCurve = keyCurve
        self.rpId = rpId
        self.userHandle = userHandle
        self.userName = userName
        self.counter = counter
        self.rpName = rpName
        self.userDisplayName = userDisplayName
        self.creationDate = creationDate
    }
}



extension Fido2CredentialNewView: Equatable, Hashable {
    public static func ==(lhs: Fido2CredentialNewView, rhs: Fido2CredentialNewView) -> Bool {
        if lhs.credentialId != rhs.credentialId {
            return false
        }
        if lhs.keyType != rhs.keyType {
            return false
        }
        if lhs.keyAlgorithm != rhs.keyAlgorithm {
            return false
        }
        if lhs.keyCurve != rhs.keyCurve {
            return false
        }
        if lhs.rpId != rhs.rpId {
            return false
        }
        if lhs.userHandle != rhs.userHandle {
            return false
        }
        if lhs.userName != rhs.userName {
            return false
        }
        if lhs.counter != rhs.counter {
            return false
        }
        if lhs.rpName != rhs.rpName {
            return false
        }
        if lhs.userDisplayName != rhs.userDisplayName {
            return false
        }
        if lhs.creationDate != rhs.creationDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(credentialId)
        hasher.combine(keyType)
        hasher.combine(keyAlgorithm)
        hasher.combine(keyCurve)
        hasher.combine(rpId)
        hasher.combine(userHandle)
        hasher.combine(userName)
        hasher.combine(counter)
        hasher.combine(rpName)
        hasher.combine(userDisplayName)
        hasher.combine(creationDate)
    }
}


public struct FfiConverterTypeFido2CredentialNewView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fido2CredentialNewView {
        return
            try Fido2CredentialNewView(
                credentialId: FfiConverterString.read(from: &buf), 
                keyType: FfiConverterString.read(from: &buf), 
                keyAlgorithm: FfiConverterString.read(from: &buf), 
                keyCurve: FfiConverterString.read(from: &buf), 
                rpId: FfiConverterString.read(from: &buf), 
                userHandle: FfiConverterOptionString.read(from: &buf), 
                userName: FfiConverterOptionString.read(from: &buf), 
                counter: FfiConverterString.read(from: &buf), 
                rpName: FfiConverterOptionString.read(from: &buf), 
                userDisplayName: FfiConverterOptionString.read(from: &buf), 
                creationDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Fido2CredentialNewView, into buf: inout [UInt8]) {
        FfiConverterString.write(value.credentialId, into: &buf)
        FfiConverterString.write(value.keyType, into: &buf)
        FfiConverterString.write(value.keyAlgorithm, into: &buf)
        FfiConverterString.write(value.keyCurve, into: &buf)
        FfiConverterString.write(value.rpId, into: &buf)
        FfiConverterOptionString.write(value.userHandle, into: &buf)
        FfiConverterOptionString.write(value.userName, into: &buf)
        FfiConverterString.write(value.counter, into: &buf)
        FfiConverterOptionString.write(value.rpName, into: &buf)
        FfiConverterOptionString.write(value.userDisplayName, into: &buf)
        FfiConverterTypeDateTime.write(value.creationDate, into: &buf)
    }
}


public func FfiConverterTypeFido2CredentialNewView_lift(_ buf: RustBuffer) throws -> Fido2CredentialNewView {
    return try FfiConverterTypeFido2CredentialNewView.lift(buf)
}

public func FfiConverterTypeFido2CredentialNewView_lower(_ value: Fido2CredentialNewView) -> RustBuffer {
    return FfiConverterTypeFido2CredentialNewView.lower(value)
}


public struct Fido2CredentialView {
    public let credentialId: String
    public let keyType: String
    public let keyAlgorithm: String
    public let keyCurve: String
    public let keyValue: EncString
    public let rpId: String
    public let userHandle: String?
    public let userName: String?
    public let counter: String
    public let rpName: String?
    public let userDisplayName: String?
    public let discoverable: String
    public let creationDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(credentialId: String, keyType: String, keyAlgorithm: String, keyCurve: String, keyValue: EncString, rpId: String, userHandle: String?, userName: String?, counter: String, rpName: String?, userDisplayName: String?, discoverable: String, creationDate: DateTime) {
        self.credentialId = credentialId
        self.keyType = keyType
        self.keyAlgorithm = keyAlgorithm
        self.keyCurve = keyCurve
        self.keyValue = keyValue
        self.rpId = rpId
        self.userHandle = userHandle
        self.userName = userName
        self.counter = counter
        self.rpName = rpName
        self.userDisplayName = userDisplayName
        self.discoverable = discoverable
        self.creationDate = creationDate
    }
}



extension Fido2CredentialView: Equatable, Hashable {
    public static func ==(lhs: Fido2CredentialView, rhs: Fido2CredentialView) -> Bool {
        if lhs.credentialId != rhs.credentialId {
            return false
        }
        if lhs.keyType != rhs.keyType {
            return false
        }
        if lhs.keyAlgorithm != rhs.keyAlgorithm {
            return false
        }
        if lhs.keyCurve != rhs.keyCurve {
            return false
        }
        if lhs.keyValue != rhs.keyValue {
            return false
        }
        if lhs.rpId != rhs.rpId {
            return false
        }
        if lhs.userHandle != rhs.userHandle {
            return false
        }
        if lhs.userName != rhs.userName {
            return false
        }
        if lhs.counter != rhs.counter {
            return false
        }
        if lhs.rpName != rhs.rpName {
            return false
        }
        if lhs.userDisplayName != rhs.userDisplayName {
            return false
        }
        if lhs.discoverable != rhs.discoverable {
            return false
        }
        if lhs.creationDate != rhs.creationDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(credentialId)
        hasher.combine(keyType)
        hasher.combine(keyAlgorithm)
        hasher.combine(keyCurve)
        hasher.combine(keyValue)
        hasher.combine(rpId)
        hasher.combine(userHandle)
        hasher.combine(userName)
        hasher.combine(counter)
        hasher.combine(rpName)
        hasher.combine(userDisplayName)
        hasher.combine(discoverable)
        hasher.combine(creationDate)
    }
}


public struct FfiConverterTypeFido2CredentialView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Fido2CredentialView {
        return
            try Fido2CredentialView(
                credentialId: FfiConverterString.read(from: &buf), 
                keyType: FfiConverterString.read(from: &buf), 
                keyAlgorithm: FfiConverterString.read(from: &buf), 
                keyCurve: FfiConverterString.read(from: &buf), 
                keyValue: FfiConverterTypeEncString.read(from: &buf), 
                rpId: FfiConverterString.read(from: &buf), 
                userHandle: FfiConverterOptionString.read(from: &buf), 
                userName: FfiConverterOptionString.read(from: &buf), 
                counter: FfiConverterString.read(from: &buf), 
                rpName: FfiConverterOptionString.read(from: &buf), 
                userDisplayName: FfiConverterOptionString.read(from: &buf), 
                discoverable: FfiConverterString.read(from: &buf), 
                creationDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Fido2CredentialView, into buf: inout [UInt8]) {
        FfiConverterString.write(value.credentialId, into: &buf)
        FfiConverterString.write(value.keyType, into: &buf)
        FfiConverterString.write(value.keyAlgorithm, into: &buf)
        FfiConverterString.write(value.keyCurve, into: &buf)
        FfiConverterTypeEncString.write(value.keyValue, into: &buf)
        FfiConverterString.write(value.rpId, into: &buf)
        FfiConverterOptionString.write(value.userHandle, into: &buf)
        FfiConverterOptionString.write(value.userName, into: &buf)
        FfiConverterString.write(value.counter, into: &buf)
        FfiConverterOptionString.write(value.rpName, into: &buf)
        FfiConverterOptionString.write(value.userDisplayName, into: &buf)
        FfiConverterString.write(value.discoverable, into: &buf)
        FfiConverterTypeDateTime.write(value.creationDate, into: &buf)
    }
}


public func FfiConverterTypeFido2CredentialView_lift(_ buf: RustBuffer) throws -> Fido2CredentialView {
    return try FfiConverterTypeFido2CredentialView.lift(buf)
}

public func FfiConverterTypeFido2CredentialView_lower(_ value: Fido2CredentialView) -> RustBuffer {
    return FfiConverterTypeFido2CredentialView.lower(value)
}


public struct Field {
    public let name: EncString?
    public let value: EncString?
    public let type: FieldType
    public let linkedId: LinkedIdType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: EncString?, value: EncString?, type: FieldType, linkedId: LinkedIdType?) {
        self.name = name
        self.value = value
        self.type = type
        self.linkedId = linkedId
    }
}



extension Field: Equatable, Hashable {
    public static func ==(lhs: Field, rhs: Field) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.linkedId != rhs.linkedId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
        hasher.combine(type)
        hasher.combine(linkedId)
    }
}


public struct FfiConverterTypeField: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Field {
        return
            try Field(
                name: FfiConverterOptionTypeEncString.read(from: &buf), 
                value: FfiConverterOptionTypeEncString.read(from: &buf), 
                type: FfiConverterTypeFieldType.read(from: &buf), 
                linkedId: FfiConverterOptionTypeLinkedIdType.read(from: &buf)
        )
    }

    public static func write(_ value: Field, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.name, into: &buf)
        FfiConverterOptionTypeEncString.write(value.value, into: &buf)
        FfiConverterTypeFieldType.write(value.type, into: &buf)
        FfiConverterOptionTypeLinkedIdType.write(value.linkedId, into: &buf)
    }
}


public func FfiConverterTypeField_lift(_ buf: RustBuffer) throws -> Field {
    return try FfiConverterTypeField.lift(buf)
}

public func FfiConverterTypeField_lower(_ value: Field) -> RustBuffer {
    return FfiConverterTypeField.lower(value)
}


public struct FieldView {
    public let name: String?
    public let value: String?
    public let type: FieldType
    public let linkedId: LinkedIdType?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(name: String?, value: String?, type: FieldType, linkedId: LinkedIdType?) {
        self.name = name
        self.value = value
        self.type = type
        self.linkedId = linkedId
    }
}



extension FieldView: Equatable, Hashable {
    public static func ==(lhs: FieldView, rhs: FieldView) -> Bool {
        if lhs.name != rhs.name {
            return false
        }
        if lhs.value != rhs.value {
            return false
        }
        if lhs.type != rhs.type {
            return false
        }
        if lhs.linkedId != rhs.linkedId {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(name)
        hasher.combine(value)
        hasher.combine(type)
        hasher.combine(linkedId)
    }
}


public struct FfiConverterTypeFieldView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FieldView {
        return
            try FieldView(
                name: FfiConverterOptionString.read(from: &buf), 
                value: FfiConverterOptionString.read(from: &buf), 
                type: FfiConverterTypeFieldType.read(from: &buf), 
                linkedId: FfiConverterOptionTypeLinkedIdType.read(from: &buf)
        )
    }

    public static func write(_ value: FieldView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.name, into: &buf)
        FfiConverterOptionString.write(value.value, into: &buf)
        FfiConverterTypeFieldType.write(value.type, into: &buf)
        FfiConverterOptionTypeLinkedIdType.write(value.linkedId, into: &buf)
    }
}


public func FfiConverterTypeFieldView_lift(_ buf: RustBuffer) throws -> FieldView {
    return try FfiConverterTypeFieldView.lift(buf)
}

public func FfiConverterTypeFieldView_lower(_ value: FieldView) -> RustBuffer {
    return FfiConverterTypeFieldView.lower(value)
}


public struct Folder {
    public let id: Uuid?
    public let name: EncString
    public let revisionDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Uuid?, name: EncString, revisionDate: DateTime) {
        self.id = id
        self.name = name
        self.revisionDate = revisionDate
    }
}



extension Folder: Equatable, Hashable {
    public static func ==(lhs: Folder, rhs: Folder) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(revisionDate)
    }
}


public struct FfiConverterTypeFolder: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Folder {
        return
            try Folder(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                name: FfiConverterTypeEncString.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: Folder, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterTypeEncString.write(value.name, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
    }
}


public func FfiConverterTypeFolder_lift(_ buf: RustBuffer) throws -> Folder {
    return try FfiConverterTypeFolder.lift(buf)
}

public func FfiConverterTypeFolder_lower(_ value: Folder) -> RustBuffer {
    return FfiConverterTypeFolder.lower(value)
}


public struct FolderView {
    public let id: Uuid?
    public let name: String
    public let revisionDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(id: Uuid?, name: String, revisionDate: DateTime) {
        self.id = id
        self.name = name
        self.revisionDate = revisionDate
    }
}



extension FolderView: Equatable, Hashable {
    public static func ==(lhs: FolderView, rhs: FolderView) -> Bool {
        if lhs.id != rhs.id {
            return false
        }
        if lhs.name != rhs.name {
            return false
        }
        if lhs.revisionDate != rhs.revisionDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(id)
        hasher.combine(name)
        hasher.combine(revisionDate)
    }
}


public struct FfiConverterTypeFolderView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FolderView {
        return
            try FolderView(
                id: FfiConverterOptionTypeUuid.read(from: &buf), 
                name: FfiConverterString.read(from: &buf), 
                revisionDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: FolderView, into buf: inout [UInt8]) {
        FfiConverterOptionTypeUuid.write(value.id, into: &buf)
        FfiConverterString.write(value.name, into: &buf)
        FfiConverterTypeDateTime.write(value.revisionDate, into: &buf)
    }
}


public func FfiConverterTypeFolderView_lift(_ buf: RustBuffer) throws -> FolderView {
    return try FfiConverterTypeFolderView.lift(buf)
}

public func FfiConverterTypeFolderView_lower(_ value: FolderView) -> RustBuffer {
    return FfiConverterTypeFolderView.lower(value)
}


public struct Identity {
    public let title: EncString?
    public let firstName: EncString?
    public let middleName: EncString?
    public let lastName: EncString?
    public let address1: EncString?
    public let address2: EncString?
    public let address3: EncString?
    public let city: EncString?
    public let state: EncString?
    public let postalCode: EncString?
    public let country: EncString?
    public let company: EncString?
    public let email: EncString?
    public let phone: EncString?
    public let ssn: EncString?
    public let username: EncString?
    public let passportNumber: EncString?
    public let licenseNumber: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: EncString?, firstName: EncString?, middleName: EncString?, lastName: EncString?, address1: EncString?, address2: EncString?, address3: EncString?, city: EncString?, state: EncString?, postalCode: EncString?, country: EncString?, company: EncString?, email: EncString?, phone: EncString?, ssn: EncString?, username: EncString?, passportNumber: EncString?, licenseNumber: EncString?) {
        self.title = title
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.city = city
        self.state = state
        self.postalCode = postalCode
        self.country = country
        self.company = company
        self.email = email
        self.phone = phone
        self.ssn = ssn
        self.username = username
        self.passportNumber = passportNumber
        self.licenseNumber = licenseNumber
    }
}



extension Identity: Equatable, Hashable {
    public static func ==(lhs: Identity, rhs: Identity) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.middleName != rhs.middleName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.address1 != rhs.address1 {
            return false
        }
        if lhs.address2 != rhs.address2 {
            return false
        }
        if lhs.address3 != rhs.address3 {
            return false
        }
        if lhs.city != rhs.city {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        if lhs.postalCode != rhs.postalCode {
            return false
        }
        if lhs.country != rhs.country {
            return false
        }
        if lhs.company != rhs.company {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.phone != rhs.phone {
            return false
        }
        if lhs.ssn != rhs.ssn {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        if lhs.passportNumber != rhs.passportNumber {
            return false
        }
        if lhs.licenseNumber != rhs.licenseNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(firstName)
        hasher.combine(middleName)
        hasher.combine(lastName)
        hasher.combine(address1)
        hasher.combine(address2)
        hasher.combine(address3)
        hasher.combine(city)
        hasher.combine(state)
        hasher.combine(postalCode)
        hasher.combine(country)
        hasher.combine(company)
        hasher.combine(email)
        hasher.combine(phone)
        hasher.combine(ssn)
        hasher.combine(username)
        hasher.combine(passportNumber)
        hasher.combine(licenseNumber)
    }
}


public struct FfiConverterTypeIdentity: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Identity {
        return
            try Identity(
                title: FfiConverterOptionTypeEncString.read(from: &buf), 
                firstName: FfiConverterOptionTypeEncString.read(from: &buf), 
                middleName: FfiConverterOptionTypeEncString.read(from: &buf), 
                lastName: FfiConverterOptionTypeEncString.read(from: &buf), 
                address1: FfiConverterOptionTypeEncString.read(from: &buf), 
                address2: FfiConverterOptionTypeEncString.read(from: &buf), 
                address3: FfiConverterOptionTypeEncString.read(from: &buf), 
                city: FfiConverterOptionTypeEncString.read(from: &buf), 
                state: FfiConverterOptionTypeEncString.read(from: &buf), 
                postalCode: FfiConverterOptionTypeEncString.read(from: &buf), 
                country: FfiConverterOptionTypeEncString.read(from: &buf), 
                company: FfiConverterOptionTypeEncString.read(from: &buf), 
                email: FfiConverterOptionTypeEncString.read(from: &buf), 
                phone: FfiConverterOptionTypeEncString.read(from: &buf), 
                ssn: FfiConverterOptionTypeEncString.read(from: &buf), 
                username: FfiConverterOptionTypeEncString.read(from: &buf), 
                passportNumber: FfiConverterOptionTypeEncString.read(from: &buf), 
                licenseNumber: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: Identity, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.title, into: &buf)
        FfiConverterOptionTypeEncString.write(value.firstName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.middleName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.lastName, into: &buf)
        FfiConverterOptionTypeEncString.write(value.address1, into: &buf)
        FfiConverterOptionTypeEncString.write(value.address2, into: &buf)
        FfiConverterOptionTypeEncString.write(value.address3, into: &buf)
        FfiConverterOptionTypeEncString.write(value.city, into: &buf)
        FfiConverterOptionTypeEncString.write(value.state, into: &buf)
        FfiConverterOptionTypeEncString.write(value.postalCode, into: &buf)
        FfiConverterOptionTypeEncString.write(value.country, into: &buf)
        FfiConverterOptionTypeEncString.write(value.company, into: &buf)
        FfiConverterOptionTypeEncString.write(value.email, into: &buf)
        FfiConverterOptionTypeEncString.write(value.phone, into: &buf)
        FfiConverterOptionTypeEncString.write(value.ssn, into: &buf)
        FfiConverterOptionTypeEncString.write(value.username, into: &buf)
        FfiConverterOptionTypeEncString.write(value.passportNumber, into: &buf)
        FfiConverterOptionTypeEncString.write(value.licenseNumber, into: &buf)
    }
}


public func FfiConverterTypeIdentity_lift(_ buf: RustBuffer) throws -> Identity {
    return try FfiConverterTypeIdentity.lift(buf)
}

public func FfiConverterTypeIdentity_lower(_ value: Identity) -> RustBuffer {
    return FfiConverterTypeIdentity.lower(value)
}


public struct IdentityView {
    public let title: String?
    public let firstName: String?
    public let middleName: String?
    public let lastName: String?
    public let address1: String?
    public let address2: String?
    public let address3: String?
    public let city: String?
    public let state: String?
    public let postalCode: String?
    public let country: String?
    public let company: String?
    public let email: String?
    public let phone: String?
    public let ssn: String?
    public let username: String?
    public let passportNumber: String?
    public let licenseNumber: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(title: String?, firstName: String?, middleName: String?, lastName: String?, address1: String?, address2: String?, address3: String?, city: String?, state: String?, postalCode: String?, country: String?, company: String?, email: String?, phone: String?, ssn: String?, username: String?, passportNumber: String?, licenseNumber: String?) {
        self.title = title
        self.firstName = firstName
        self.middleName = middleName
        self.lastName = lastName
        self.address1 = address1
        self.address2 = address2
        self.address3 = address3
        self.city = city
        self.state = state
        self.postalCode = postalCode
        self.country = country
        self.company = company
        self.email = email
        self.phone = phone
        self.ssn = ssn
        self.username = username
        self.passportNumber = passportNumber
        self.licenseNumber = licenseNumber
    }
}



extension IdentityView: Equatable, Hashable {
    public static func ==(lhs: IdentityView, rhs: IdentityView) -> Bool {
        if lhs.title != rhs.title {
            return false
        }
        if lhs.firstName != rhs.firstName {
            return false
        }
        if lhs.middleName != rhs.middleName {
            return false
        }
        if lhs.lastName != rhs.lastName {
            return false
        }
        if lhs.address1 != rhs.address1 {
            return false
        }
        if lhs.address2 != rhs.address2 {
            return false
        }
        if lhs.address3 != rhs.address3 {
            return false
        }
        if lhs.city != rhs.city {
            return false
        }
        if lhs.state != rhs.state {
            return false
        }
        if lhs.postalCode != rhs.postalCode {
            return false
        }
        if lhs.country != rhs.country {
            return false
        }
        if lhs.company != rhs.company {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.phone != rhs.phone {
            return false
        }
        if lhs.ssn != rhs.ssn {
            return false
        }
        if lhs.username != rhs.username {
            return false
        }
        if lhs.passportNumber != rhs.passportNumber {
            return false
        }
        if lhs.licenseNumber != rhs.licenseNumber {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(title)
        hasher.combine(firstName)
        hasher.combine(middleName)
        hasher.combine(lastName)
        hasher.combine(address1)
        hasher.combine(address2)
        hasher.combine(address3)
        hasher.combine(city)
        hasher.combine(state)
        hasher.combine(postalCode)
        hasher.combine(country)
        hasher.combine(company)
        hasher.combine(email)
        hasher.combine(phone)
        hasher.combine(ssn)
        hasher.combine(username)
        hasher.combine(passportNumber)
        hasher.combine(licenseNumber)
    }
}


public struct FfiConverterTypeIdentityView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> IdentityView {
        return
            try IdentityView(
                title: FfiConverterOptionString.read(from: &buf), 
                firstName: FfiConverterOptionString.read(from: &buf), 
                middleName: FfiConverterOptionString.read(from: &buf), 
                lastName: FfiConverterOptionString.read(from: &buf), 
                address1: FfiConverterOptionString.read(from: &buf), 
                address2: FfiConverterOptionString.read(from: &buf), 
                address3: FfiConverterOptionString.read(from: &buf), 
                city: FfiConverterOptionString.read(from: &buf), 
                state: FfiConverterOptionString.read(from: &buf), 
                postalCode: FfiConverterOptionString.read(from: &buf), 
                country: FfiConverterOptionString.read(from: &buf), 
                company: FfiConverterOptionString.read(from: &buf), 
                email: FfiConverterOptionString.read(from: &buf), 
                phone: FfiConverterOptionString.read(from: &buf), 
                ssn: FfiConverterOptionString.read(from: &buf), 
                username: FfiConverterOptionString.read(from: &buf), 
                passportNumber: FfiConverterOptionString.read(from: &buf), 
                licenseNumber: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: IdentityView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.title, into: &buf)
        FfiConverterOptionString.write(value.firstName, into: &buf)
        FfiConverterOptionString.write(value.middleName, into: &buf)
        FfiConverterOptionString.write(value.lastName, into: &buf)
        FfiConverterOptionString.write(value.address1, into: &buf)
        FfiConverterOptionString.write(value.address2, into: &buf)
        FfiConverterOptionString.write(value.address3, into: &buf)
        FfiConverterOptionString.write(value.city, into: &buf)
        FfiConverterOptionString.write(value.state, into: &buf)
        FfiConverterOptionString.write(value.postalCode, into: &buf)
        FfiConverterOptionString.write(value.country, into: &buf)
        FfiConverterOptionString.write(value.company, into: &buf)
        FfiConverterOptionString.write(value.email, into: &buf)
        FfiConverterOptionString.write(value.phone, into: &buf)
        FfiConverterOptionString.write(value.ssn, into: &buf)
        FfiConverterOptionString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.passportNumber, into: &buf)
        FfiConverterOptionString.write(value.licenseNumber, into: &buf)
    }
}


public func FfiConverterTypeIdentityView_lift(_ buf: RustBuffer) throws -> IdentityView {
    return try FfiConverterTypeIdentityView.lift(buf)
}

public func FfiConverterTypeIdentityView_lower(_ value: IdentityView) -> RustBuffer {
    return FfiConverterTypeIdentityView.lower(value)
}


public struct LocalData {
    public let lastUsedDate: UInt32?
    public let lastLaunched: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastUsedDate: UInt32?, lastLaunched: UInt32?) {
        self.lastUsedDate = lastUsedDate
        self.lastLaunched = lastLaunched
    }
}



extension LocalData: Equatable, Hashable {
    public static func ==(lhs: LocalData, rhs: LocalData) -> Bool {
        if lhs.lastUsedDate != rhs.lastUsedDate {
            return false
        }
        if lhs.lastLaunched != rhs.lastLaunched {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUsedDate)
        hasher.combine(lastLaunched)
    }
}


public struct FfiConverterTypeLocalData: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalData {
        return
            try LocalData(
                lastUsedDate: FfiConverterOptionUInt32.read(from: &buf), 
                lastLaunched: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LocalData, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.lastUsedDate, into: &buf)
        FfiConverterOptionUInt32.write(value.lastLaunched, into: &buf)
    }
}


public func FfiConverterTypeLocalData_lift(_ buf: RustBuffer) throws -> LocalData {
    return try FfiConverterTypeLocalData.lift(buf)
}

public func FfiConverterTypeLocalData_lower(_ value: LocalData) -> RustBuffer {
    return FfiConverterTypeLocalData.lower(value)
}


public struct LocalDataView {
    public let lastUsedDate: UInt32?
    public let lastLaunched: UInt32?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(lastUsedDate: UInt32?, lastLaunched: UInt32?) {
        self.lastUsedDate = lastUsedDate
        self.lastLaunched = lastLaunched
    }
}



extension LocalDataView: Equatable, Hashable {
    public static func ==(lhs: LocalDataView, rhs: LocalDataView) -> Bool {
        if lhs.lastUsedDate != rhs.lastUsedDate {
            return false
        }
        if lhs.lastLaunched != rhs.lastLaunched {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(lastUsedDate)
        hasher.combine(lastLaunched)
    }
}


public struct FfiConverterTypeLocalDataView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LocalDataView {
        return
            try LocalDataView(
                lastUsedDate: FfiConverterOptionUInt32.read(from: &buf), 
                lastLaunched: FfiConverterOptionUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: LocalDataView, into buf: inout [UInt8]) {
        FfiConverterOptionUInt32.write(value.lastUsedDate, into: &buf)
        FfiConverterOptionUInt32.write(value.lastLaunched, into: &buf)
    }
}


public func FfiConverterTypeLocalDataView_lift(_ buf: RustBuffer) throws -> LocalDataView {
    return try FfiConverterTypeLocalDataView.lift(buf)
}

public func FfiConverterTypeLocalDataView_lower(_ value: LocalDataView) -> RustBuffer {
    return FfiConverterTypeLocalDataView.lower(value)
}


public struct Login {
    public let username: EncString?
    public let password: EncString?
    public let passwordRevisionDate: DateTime?
    public let uris: [LoginUri]?
    public let totp: EncString?
    public let autofillOnPageLoad: Bool?
    public let fido2Credentials: [Fido2Credential]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: EncString?, password: EncString?, passwordRevisionDate: DateTime?, uris: [LoginUri]?, totp: EncString?, autofillOnPageLoad: Bool?, fido2Credentials: [Fido2Credential]?) {
        self.username = username
        self.password = password
        self.passwordRevisionDate = passwordRevisionDate
        self.uris = uris
        self.totp = totp
        self.autofillOnPageLoad = autofillOnPageLoad
        self.fido2Credentials = fido2Credentials
    }
}



extension Login: Equatable, Hashable {
    public static func ==(lhs: Login, rhs: Login) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.passwordRevisionDate != rhs.passwordRevisionDate {
            return false
        }
        if lhs.uris != rhs.uris {
            return false
        }
        if lhs.totp != rhs.totp {
            return false
        }
        if lhs.autofillOnPageLoad != rhs.autofillOnPageLoad {
            return false
        }
        if lhs.fido2Credentials != rhs.fido2Credentials {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(password)
        hasher.combine(passwordRevisionDate)
        hasher.combine(uris)
        hasher.combine(totp)
        hasher.combine(autofillOnPageLoad)
        hasher.combine(fido2Credentials)
    }
}


public struct FfiConverterTypeLogin: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Login {
        return
            try Login(
                username: FfiConverterOptionTypeEncString.read(from: &buf), 
                password: FfiConverterOptionTypeEncString.read(from: &buf), 
                passwordRevisionDate: FfiConverterOptionTypeDateTime.read(from: &buf), 
                uris: FfiConverterOptionSequenceTypeLoginUri.read(from: &buf), 
                totp: FfiConverterOptionTypeEncString.read(from: &buf), 
                autofillOnPageLoad: FfiConverterOptionBool.read(from: &buf), 
                fido2Credentials: FfiConverterOptionSequenceTypeFido2Credential.read(from: &buf)
        )
    }

    public static func write(_ value: Login, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.username, into: &buf)
        FfiConverterOptionTypeEncString.write(value.password, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.passwordRevisionDate, into: &buf)
        FfiConverterOptionSequenceTypeLoginUri.write(value.uris, into: &buf)
        FfiConverterOptionTypeEncString.write(value.totp, into: &buf)
        FfiConverterOptionBool.write(value.autofillOnPageLoad, into: &buf)
        FfiConverterOptionSequenceTypeFido2Credential.write(value.fido2Credentials, into: &buf)
    }
}


public func FfiConverterTypeLogin_lift(_ buf: RustBuffer) throws -> Login {
    return try FfiConverterTypeLogin.lift(buf)
}

public func FfiConverterTypeLogin_lower(_ value: Login) -> RustBuffer {
    return FfiConverterTypeLogin.lower(value)
}


public struct LoginUri {
    public let uri: EncString?
    public let match: UriMatchType?
    public let uriChecksum: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uri: EncString?, match: UriMatchType?, uriChecksum: EncString?) {
        self.uri = uri
        self.match = match
        self.uriChecksum = uriChecksum
    }
}



extension LoginUri: Equatable, Hashable {
    public static func ==(lhs: LoginUri, rhs: LoginUri) -> Bool {
        if lhs.uri != rhs.uri {
            return false
        }
        if lhs.match != rhs.match {
            return false
        }
        if lhs.uriChecksum != rhs.uriChecksum {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uri)
        hasher.combine(match)
        hasher.combine(uriChecksum)
    }
}


public struct FfiConverterTypeLoginUri: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoginUri {
        return
            try LoginUri(
                uri: FfiConverterOptionTypeEncString.read(from: &buf), 
                match: FfiConverterOptionTypeUriMatchType.read(from: &buf), 
                uriChecksum: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: LoginUri, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.uri, into: &buf)
        FfiConverterOptionTypeUriMatchType.write(value.match, into: &buf)
        FfiConverterOptionTypeEncString.write(value.uriChecksum, into: &buf)
    }
}


public func FfiConverterTypeLoginUri_lift(_ buf: RustBuffer) throws -> LoginUri {
    return try FfiConverterTypeLoginUri.lift(buf)
}

public func FfiConverterTypeLoginUri_lower(_ value: LoginUri) -> RustBuffer {
    return FfiConverterTypeLoginUri.lower(value)
}


public struct LoginUriView {
    public let uri: String?
    public let match: UriMatchType?
    public let uriChecksum: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uri: String?, match: UriMatchType?, uriChecksum: String?) {
        self.uri = uri
        self.match = match
        self.uriChecksum = uriChecksum
    }
}



extension LoginUriView: Equatable, Hashable {
    public static func ==(lhs: LoginUriView, rhs: LoginUriView) -> Bool {
        if lhs.uri != rhs.uri {
            return false
        }
        if lhs.match != rhs.match {
            return false
        }
        if lhs.uriChecksum != rhs.uriChecksum {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uri)
        hasher.combine(match)
        hasher.combine(uriChecksum)
    }
}


public struct FfiConverterTypeLoginUriView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoginUriView {
        return
            try LoginUriView(
                uri: FfiConverterOptionString.read(from: &buf), 
                match: FfiConverterOptionTypeUriMatchType.read(from: &buf), 
                uriChecksum: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: LoginUriView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.uri, into: &buf)
        FfiConverterOptionTypeUriMatchType.write(value.match, into: &buf)
        FfiConverterOptionString.write(value.uriChecksum, into: &buf)
    }
}


public func FfiConverterTypeLoginUriView_lift(_ buf: RustBuffer) throws -> LoginUriView {
    return try FfiConverterTypeLoginUriView.lift(buf)
}

public func FfiConverterTypeLoginUriView_lower(_ value: LoginUriView) -> RustBuffer {
    return FfiConverterTypeLoginUriView.lower(value)
}


public struct LoginView {
    public let username: String?
    public let password: String?
    public let passwordRevisionDate: DateTime?
    public let uris: [LoginUriView]?
    public let totp: String?
    public let autofillOnPageLoad: Bool?
    public let fido2Credentials: [Fido2Credential]?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(username: String?, password: String?, passwordRevisionDate: DateTime?, uris: [LoginUriView]?, totp: String?, autofillOnPageLoad: Bool?, fido2Credentials: [Fido2Credential]?) {
        self.username = username
        self.password = password
        self.passwordRevisionDate = passwordRevisionDate
        self.uris = uris
        self.totp = totp
        self.autofillOnPageLoad = autofillOnPageLoad
        self.fido2Credentials = fido2Credentials
    }
}



extension LoginView: Equatable, Hashable {
    public static func ==(lhs: LoginView, rhs: LoginView) -> Bool {
        if lhs.username != rhs.username {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.passwordRevisionDate != rhs.passwordRevisionDate {
            return false
        }
        if lhs.uris != rhs.uris {
            return false
        }
        if lhs.totp != rhs.totp {
            return false
        }
        if lhs.autofillOnPageLoad != rhs.autofillOnPageLoad {
            return false
        }
        if lhs.fido2Credentials != rhs.fido2Credentials {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(username)
        hasher.combine(password)
        hasher.combine(passwordRevisionDate)
        hasher.combine(uris)
        hasher.combine(totp)
        hasher.combine(autofillOnPageLoad)
        hasher.combine(fido2Credentials)
    }
}


public struct FfiConverterTypeLoginView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LoginView {
        return
            try LoginView(
                username: FfiConverterOptionString.read(from: &buf), 
                password: FfiConverterOptionString.read(from: &buf), 
                passwordRevisionDate: FfiConverterOptionTypeDateTime.read(from: &buf), 
                uris: FfiConverterOptionSequenceTypeLoginUriView.read(from: &buf), 
                totp: FfiConverterOptionString.read(from: &buf), 
                autofillOnPageLoad: FfiConverterOptionBool.read(from: &buf), 
                fido2Credentials: FfiConverterOptionSequenceTypeFido2Credential.read(from: &buf)
        )
    }

    public static func write(_ value: LoginView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.username, into: &buf)
        FfiConverterOptionString.write(value.password, into: &buf)
        FfiConverterOptionTypeDateTime.write(value.passwordRevisionDate, into: &buf)
        FfiConverterOptionSequenceTypeLoginUriView.write(value.uris, into: &buf)
        FfiConverterOptionString.write(value.totp, into: &buf)
        FfiConverterOptionBool.write(value.autofillOnPageLoad, into: &buf)
        FfiConverterOptionSequenceTypeFido2Credential.write(value.fido2Credentials, into: &buf)
    }
}


public func FfiConverterTypeLoginView_lift(_ buf: RustBuffer) throws -> LoginView {
    return try FfiConverterTypeLoginView.lift(buf)
}

public func FfiConverterTypeLoginView_lower(_ value: LoginView) -> RustBuffer {
    return FfiConverterTypeLoginView.lower(value)
}


public struct PasswordHistory {
    public let password: EncString
    public let lastUsedDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(password: EncString, lastUsedDate: DateTime) {
        self.password = password
        self.lastUsedDate = lastUsedDate
    }
}



extension PasswordHistory: Equatable, Hashable {
    public static func ==(lhs: PasswordHistory, rhs: PasswordHistory) -> Bool {
        if lhs.password != rhs.password {
            return false
        }
        if lhs.lastUsedDate != rhs.lastUsedDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(password)
        hasher.combine(lastUsedDate)
    }
}


public struct FfiConverterTypePasswordHistory: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PasswordHistory {
        return
            try PasswordHistory(
                password: FfiConverterTypeEncString.read(from: &buf), 
                lastUsedDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: PasswordHistory, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.password, into: &buf)
        FfiConverterTypeDateTime.write(value.lastUsedDate, into: &buf)
    }
}


public func FfiConverterTypePasswordHistory_lift(_ buf: RustBuffer) throws -> PasswordHistory {
    return try FfiConverterTypePasswordHistory.lift(buf)
}

public func FfiConverterTypePasswordHistory_lower(_ value: PasswordHistory) -> RustBuffer {
    return FfiConverterTypePasswordHistory.lower(value)
}


public struct PasswordHistoryView {
    public let password: String
    public let lastUsedDate: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(password: String, lastUsedDate: DateTime) {
        self.password = password
        self.lastUsedDate = lastUsedDate
    }
}



extension PasswordHistoryView: Equatable, Hashable {
    public static func ==(lhs: PasswordHistoryView, rhs: PasswordHistoryView) -> Bool {
        if lhs.password != rhs.password {
            return false
        }
        if lhs.lastUsedDate != rhs.lastUsedDate {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(password)
        hasher.combine(lastUsedDate)
    }
}


public struct FfiConverterTypePasswordHistoryView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> PasswordHistoryView {
        return
            try PasswordHistoryView(
                password: FfiConverterString.read(from: &buf), 
                lastUsedDate: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: PasswordHistoryView, into buf: inout [UInt8]) {
        FfiConverterString.write(value.password, into: &buf)
        FfiConverterTypeDateTime.write(value.lastUsedDate, into: &buf)
    }
}


public func FfiConverterTypePasswordHistoryView_lift(_ buf: RustBuffer) throws -> PasswordHistoryView {
    return try FfiConverterTypePasswordHistoryView.lift(buf)
}

public func FfiConverterTypePasswordHistoryView_lower(_ value: PasswordHistoryView) -> RustBuffer {
    return FfiConverterTypePasswordHistoryView.lower(value)
}


public struct SecureNote {
    public let type: SecureNoteType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: SecureNoteType) {
        self.type = type
    }
}



extension SecureNote: Equatable, Hashable {
    public static func ==(lhs: SecureNote, rhs: SecureNote) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
    }
}


public struct FfiConverterTypeSecureNote: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureNote {
        return
            try SecureNote(
                type: FfiConverterTypeSecureNoteType.read(from: &buf)
        )
    }

    public static func write(_ value: SecureNote, into buf: inout [UInt8]) {
        FfiConverterTypeSecureNoteType.write(value.type, into: &buf)
    }
}


public func FfiConverterTypeSecureNote_lift(_ buf: RustBuffer) throws -> SecureNote {
    return try FfiConverterTypeSecureNote.lift(buf)
}

public func FfiConverterTypeSecureNote_lower(_ value: SecureNote) -> RustBuffer {
    return FfiConverterTypeSecureNote.lower(value)
}


public struct SecureNoteView {
    public let type: SecureNoteType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(type: SecureNoteType) {
        self.type = type
    }
}



extension SecureNoteView: Equatable, Hashable {
    public static func ==(lhs: SecureNoteView, rhs: SecureNoteView) -> Bool {
        if lhs.type != rhs.type {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(type)
    }
}


public struct FfiConverterTypeSecureNoteView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureNoteView {
        return
            try SecureNoteView(
                type: FfiConverterTypeSecureNoteType.read(from: &buf)
        )
    }

    public static func write(_ value: SecureNoteView, into buf: inout [UInt8]) {
        FfiConverterTypeSecureNoteType.write(value.type, into: &buf)
    }
}


public func FfiConverterTypeSecureNoteView_lift(_ buf: RustBuffer) throws -> SecureNoteView {
    return try FfiConverterTypeSecureNoteView.lift(buf)
}

public func FfiConverterTypeSecureNoteView_lower(_ value: SecureNoteView) -> RustBuffer {
    return FfiConverterTypeSecureNoteView.lower(value)
}


public struct SshKey {
    /**
     * SSH private key (ed25519/rsa) in unencrypted openssh private key format [OpenSSH private key](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key)
     */
    public let privateKey: EncString?
    /**
     * SSH public key (ed25519/rsa) according to [RFC4253](https://datatracker.ietf.org/doc/html/rfc4253#section-6.6)
     */
    public let publicKey: EncString?
    /**
     * SSH fingerprint using SHA256 in the format: `SHA256:BASE64_ENCODED_FINGERPRINT`
     */
    public let fingerprint: EncString?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * SSH private key (ed25519/rsa) in unencrypted openssh private key format [OpenSSH private key](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key)
         */privateKey: EncString?, 
        /**
         * SSH public key (ed25519/rsa) according to [RFC4253](https://datatracker.ietf.org/doc/html/rfc4253#section-6.6)
         */publicKey: EncString?, 
        /**
         * SSH fingerprint using SHA256 in the format: `SHA256:BASE64_ENCODED_FINGERPRINT`
         */fingerprint: EncString?) {
        self.privateKey = privateKey
        self.publicKey = publicKey
        self.fingerprint = fingerprint
    }
}



extension SshKey: Equatable, Hashable {
    public static func ==(lhs: SshKey, rhs: SshKey) -> Bool {
        if lhs.privateKey != rhs.privateKey {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.fingerprint != rhs.fingerprint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(privateKey)
        hasher.combine(publicKey)
        hasher.combine(fingerprint)
    }
}


public struct FfiConverterTypeSshKey: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SshKey {
        return
            try SshKey(
                privateKey: FfiConverterOptionTypeEncString.read(from: &buf), 
                publicKey: FfiConverterOptionTypeEncString.read(from: &buf), 
                fingerprint: FfiConverterOptionTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: SshKey, into buf: inout [UInt8]) {
        FfiConverterOptionTypeEncString.write(value.privateKey, into: &buf)
        FfiConverterOptionTypeEncString.write(value.publicKey, into: &buf)
        FfiConverterOptionTypeEncString.write(value.fingerprint, into: &buf)
    }
}


public func FfiConverterTypeSshKey_lift(_ buf: RustBuffer) throws -> SshKey {
    return try FfiConverterTypeSshKey.lift(buf)
}

public func FfiConverterTypeSshKey_lower(_ value: SshKey) -> RustBuffer {
    return FfiConverterTypeSshKey.lower(value)
}


public struct SshKeyView {
    /**
     * SSH private key (ed25519/rsa) in unencrypted openssh private key format [OpenSSH private key](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key)
     */
    public let privateKey: String?
    /**
     * SSH public key (ed25519/rsa) according to [RFC4253](https://datatracker.ietf.org/doc/html/rfc4253#section-6.6)
     */
    public let publicKey: String?
    /**
     * SSH fingerprint using SHA256 in the format: `SHA256:BASE64_ENCODED_FINGERPRINT`
     */
    public let fingerprint: String?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * SSH private key (ed25519/rsa) in unencrypted openssh private key format [OpenSSH private key](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.key)
         */privateKey: String?, 
        /**
         * SSH public key (ed25519/rsa) according to [RFC4253](https://datatracker.ietf.org/doc/html/rfc4253#section-6.6)
         */publicKey: String?, 
        /**
         * SSH fingerprint using SHA256 in the format: `SHA256:BASE64_ENCODED_FINGERPRINT`
         */fingerprint: String?) {
        self.privateKey = privateKey
        self.publicKey = publicKey
        self.fingerprint = fingerprint
    }
}



extension SshKeyView: Equatable, Hashable {
    public static func ==(lhs: SshKeyView, rhs: SshKeyView) -> Bool {
        if lhs.privateKey != rhs.privateKey {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.fingerprint != rhs.fingerprint {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(privateKey)
        hasher.combine(publicKey)
        hasher.combine(fingerprint)
    }
}


public struct FfiConverterTypeSshKeyView: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SshKeyView {
        return
            try SshKeyView(
                privateKey: FfiConverterOptionString.read(from: &buf), 
                publicKey: FfiConverterOptionString.read(from: &buf), 
                fingerprint: FfiConverterOptionString.read(from: &buf)
        )
    }

    public static func write(_ value: SshKeyView, into buf: inout [UInt8]) {
        FfiConverterOptionString.write(value.privateKey, into: &buf)
        FfiConverterOptionString.write(value.publicKey, into: &buf)
        FfiConverterOptionString.write(value.fingerprint, into: &buf)
    }
}


public func FfiConverterTypeSshKeyView_lift(_ buf: RustBuffer) throws -> SshKeyView {
    return try FfiConverterTypeSshKeyView.lift(buf)
}

public func FfiConverterTypeSshKeyView_lower(_ value: SshKeyView) -> RustBuffer {
    return FfiConverterTypeSshKeyView.lower(value)
}


public struct TotpResponse {
    /**
     * Generated TOTP code
     */
    public let code: String
    /**
     * Time period
     */
    public let period: UInt32

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Generated TOTP code
         */code: String, 
        /**
         * Time period
         */period: UInt32) {
        self.code = code
        self.period = period
    }
}



extension TotpResponse: Equatable, Hashable {
    public static func ==(lhs: TotpResponse, rhs: TotpResponse) -> Bool {
        if lhs.code != rhs.code {
            return false
        }
        if lhs.period != rhs.period {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(code)
        hasher.combine(period)
    }
}


public struct FfiConverterTypeTotpResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> TotpResponse {
        return
            try TotpResponse(
                code: FfiConverterString.read(from: &buf), 
                period: FfiConverterUInt32.read(from: &buf)
        )
    }

    public static func write(_ value: TotpResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.code, into: &buf)
        FfiConverterUInt32.write(value.period, into: &buf)
    }
}


public func FfiConverterTypeTotpResponse_lift(_ buf: RustBuffer) throws -> TotpResponse {
    return try FfiConverterTypeTotpResponse.lift(buf)
}

public func FfiConverterTypeTotpResponse_lower(_ value: TotpResponse) -> RustBuffer {
    return FfiConverterTypeTotpResponse.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CipherListViewType {
    
    case login(hasFido2: Bool, totp: EncString?
    )
    case secureNote
    case card
    case identity
    case sshKey
}


public struct FfiConverterTypeCipherListViewType: FfiConverterRustBuffer {
    typealias SwiftType = CipherListViewType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherListViewType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .login(hasFido2: try FfiConverterBool.read(from: &buf), totp: try FfiConverterOptionTypeEncString.read(from: &buf)
        )
        
        case 2: return .secureNote
        
        case 3: return .card
        
        case 4: return .identity
        
        case 5: return .sshKey
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CipherListViewType, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .login(hasFido2,totp):
            writeInt(&buf, Int32(1))
            FfiConverterBool.write(hasFido2, into: &buf)
            FfiConverterOptionTypeEncString.write(totp, into: &buf)
            
        
        case .secureNote:
            writeInt(&buf, Int32(2))
        
        
        case .card:
            writeInt(&buf, Int32(3))
        
        
        case .identity:
            writeInt(&buf, Int32(4))
        
        
        case .sshKey:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeCipherListViewType_lift(_ buf: RustBuffer) throws -> CipherListViewType {
    return try FfiConverterTypeCipherListViewType.lift(buf)
}

public func FfiConverterTypeCipherListViewType_lower(_ value: CipherListViewType) -> RustBuffer {
    return FfiConverterTypeCipherListViewType.lower(value)
}



extension CipherListViewType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CipherRepromptType : UInt8 {
    
    case none = 0
    case password = 1
}


public struct FfiConverterTypeCipherRepromptType: FfiConverterRustBuffer {
    typealias SwiftType = CipherRepromptType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherRepromptType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .none
        
        case 2: return .password
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CipherRepromptType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .none:
            writeInt(&buf, Int32(1))
        
        
        case .password:
            writeInt(&buf, Int32(2))
        
        }
    }
}


public func FfiConverterTypeCipherRepromptType_lift(_ buf: RustBuffer) throws -> CipherRepromptType {
    return try FfiConverterTypeCipherRepromptType.lift(buf)
}

public func FfiConverterTypeCipherRepromptType_lower(_ value: CipherRepromptType) -> RustBuffer {
    return FfiConverterTypeCipherRepromptType.lower(value)
}



extension CipherRepromptType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum CipherType : UInt8 {
    
    case login = 1
    case secureNote = 2
    case card = 3
    case identity = 4
    case sshKey = 5
}


public struct FfiConverterTypeCipherType: FfiConverterRustBuffer {
    typealias SwiftType = CipherType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> CipherType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .login
        
        case 2: return .secureNote
        
        case 3: return .card
        
        case 4: return .identity
        
        case 5: return .sshKey
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: CipherType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .login:
            writeInt(&buf, Int32(1))
        
        
        case .secureNote:
            writeInt(&buf, Int32(2))
        
        
        case .card:
            writeInt(&buf, Int32(3))
        
        
        case .identity:
            writeInt(&buf, Int32(4))
        
        
        case .sshKey:
            writeInt(&buf, Int32(5))
        
        }
    }
}


public func FfiConverterTypeCipherType_lift(_ buf: RustBuffer) throws -> CipherType {
    return try FfiConverterTypeCipherType.lift(buf)
}

public func FfiConverterTypeCipherType_lower(_ value: CipherType) -> RustBuffer {
    return FfiConverterTypeCipherType.lower(value)
}



extension CipherType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum FieldType : UInt8 {
    
    case text = 0
    case hidden = 1
    case boolean = 2
    case linked = 3
}


public struct FfiConverterTypeFieldType: FfiConverterRustBuffer {
    typealias SwiftType = FieldType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FieldType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .text
        
        case 2: return .hidden
        
        case 3: return .boolean
        
        case 4: return .linked
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: FieldType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .text:
            writeInt(&buf, Int32(1))
        
        
        case .hidden:
            writeInt(&buf, Int32(2))
        
        
        case .boolean:
            writeInt(&buf, Int32(3))
        
        
        case .linked:
            writeInt(&buf, Int32(4))
        
        }
    }
}


public func FfiConverterTypeFieldType_lift(_ buf: RustBuffer) throws -> FieldType {
    return try FfiConverterTypeFieldType.lift(buf)
}

public func FfiConverterTypeFieldType_lower(_ value: FieldType) -> RustBuffer {
    return FfiConverterTypeFieldType.lower(value)
}



extension FieldType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum SecureNoteType : UInt8 {
    
    case generic = 0
}


public struct FfiConverterTypeSecureNoteType: FfiConverterRustBuffer {
    typealias SwiftType = SecureNoteType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SecureNoteType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .generic
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: SecureNoteType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .generic:
            writeInt(&buf, Int32(1))
        
        }
    }
}


public func FfiConverterTypeSecureNoteType_lift(_ buf: RustBuffer) throws -> SecureNoteType {
    return try FfiConverterTypeSecureNoteType.lift(buf)
}

public func FfiConverterTypeSecureNoteType_lower(_ value: SecureNoteType) -> RustBuffer {
    return FfiConverterTypeSecureNoteType.lower(value)
}



extension SecureNoteType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum UriMatchType : UInt8 {
    
    case domain = 0
    case host = 1
    case startsWith = 2
    case exact = 3
    case regularExpression = 4
    case never = 5
}


public struct FfiConverterTypeUriMatchType: FfiConverterRustBuffer {
    typealias SwiftType = UriMatchType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UriMatchType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .domain
        
        case 2: return .host
        
        case 3: return .startsWith
        
        case 4: return .exact
        
        case 5: return .regularExpression
        
        case 6: return .never
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: UriMatchType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .domain:
            writeInt(&buf, Int32(1))
        
        
        case .host:
            writeInt(&buf, Int32(2))
        
        
        case .startsWith:
            writeInt(&buf, Int32(3))
        
        
        case .exact:
            writeInt(&buf, Int32(4))
        
        
        case .regularExpression:
            writeInt(&buf, Int32(5))
        
        
        case .never:
            writeInt(&buf, Int32(6))
        
        }
    }
}


public func FfiConverterTypeUriMatchType_lift(_ buf: RustBuffer) throws -> UriMatchType {
    return try FfiConverterTypeUriMatchType.lift(buf)
}

public func FfiConverterTypeUriMatchType_lower(_ value: UriMatchType) -> RustBuffer {
    return FfiConverterTypeUriMatchType.lower(value)
}



extension UriMatchType: Equatable, Hashable {}



fileprivate struct FfiConverterOptionUInt32: FfiConverterRustBuffer {
    typealias SwiftType = UInt32?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterUInt32.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterUInt32.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionBool: FfiConverterRustBuffer {
    typealias SwiftType = Bool?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterBool.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterBool.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionString: FfiConverterRustBuffer {
    typealias SwiftType = String?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCard: FfiConverterRustBuffer {
    typealias SwiftType = Card?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCard.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCard.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeCardView: FfiConverterRustBuffer {
    typealias SwiftType = CardView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeCardView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeCardView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIdentity: FfiConverterRustBuffer {
    typealias SwiftType = Identity?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIdentity.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIdentity.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeIdentityView: FfiConverterRustBuffer {
    typealias SwiftType = IdentityView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeIdentityView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeIdentityView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLocalData: FfiConverterRustBuffer {
    typealias SwiftType = LocalData?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLocalData.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLocalData.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLocalDataView: FfiConverterRustBuffer {
    typealias SwiftType = LocalDataView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLocalDataView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLocalDataView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLogin: FfiConverterRustBuffer {
    typealias SwiftType = Login?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLogin.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLogin.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLoginView: FfiConverterRustBuffer {
    typealias SwiftType = LoginView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLoginView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLoginView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSecureNote: FfiConverterRustBuffer {
    typealias SwiftType = SecureNote?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSecureNote.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSecureNote.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSecureNoteView: FfiConverterRustBuffer {
    typealias SwiftType = SecureNoteView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSecureNoteView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSecureNoteView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSshKey: FfiConverterRustBuffer {
    typealias SwiftType = SshKey?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSshKey.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSshKey.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeSshKeyView: FfiConverterRustBuffer {
    typealias SwiftType = SshKeyView?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeSshKeyView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeSshKeyView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUriMatchType: FfiConverterRustBuffer {
    typealias SwiftType = UriMatchType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUriMatchType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUriMatchType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeAttachment: FfiConverterRustBuffer {
    typealias SwiftType = [Attachment]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAttachment.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAttachment.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeAttachmentView: FfiConverterRustBuffer {
    typealias SwiftType = [AttachmentView]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeAttachmentView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeAttachmentView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeFido2Credential: FfiConverterRustBuffer {
    typealias SwiftType = [Fido2Credential]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFido2Credential.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFido2Credential.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeField: FfiConverterRustBuffer {
    typealias SwiftType = [Field]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeField.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeField.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeFieldView: FfiConverterRustBuffer {
    typealias SwiftType = [FieldView]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeFieldView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeFieldView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeLoginUri: FfiConverterRustBuffer {
    typealias SwiftType = [LoginUri]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLoginUri.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLoginUri.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypeLoginUriView: FfiConverterRustBuffer {
    typealias SwiftType = [LoginUriView]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypeLoginUriView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypeLoginUriView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypePasswordHistory: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistory]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePasswordHistory.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePasswordHistory.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionSequenceTypePasswordHistoryView: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistoryView]?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterSequenceTypePasswordHistoryView.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterSequenceTypePasswordHistoryView.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeDateTime: FfiConverterRustBuffer {
    typealias SwiftType = DateTime?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeDateTime.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeDateTime.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeUuid: FfiConverterRustBuffer {
    typealias SwiftType = Uuid?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeUuid.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeUuid.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeEncString: FfiConverterRustBuffer {
    typealias SwiftType = EncString?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeEncString.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeEncString.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterOptionTypeLinkedIdType: FfiConverterRustBuffer {
    typealias SwiftType = LinkedIdType?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeLinkedIdType.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeLinkedIdType.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterSequenceTypeAttachment: FfiConverterRustBuffer {
    typealias SwiftType = [Attachment]

    public static func write(_ value: [Attachment], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttachment.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Attachment] {
        let len: Int32 = try readInt(&buf)
        var seq = [Attachment]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttachment.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeAttachmentView: FfiConverterRustBuffer {
    typealias SwiftType = [AttachmentView]

    public static func write(_ value: [AttachmentView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeAttachmentView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [AttachmentView] {
        let len: Int32 = try readInt(&buf)
        var seq = [AttachmentView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeAttachmentView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFido2Credential: FfiConverterRustBuffer {
    typealias SwiftType = [Fido2Credential]

    public static func write(_ value: [Fido2Credential], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFido2Credential.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Fido2Credential] {
        let len: Int32 = try readInt(&buf)
        var seq = [Fido2Credential]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFido2Credential.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeField: FfiConverterRustBuffer {
    typealias SwiftType = [Field]

    public static func write(_ value: [Field], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeField.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Field] {
        let len: Int32 = try readInt(&buf)
        var seq = [Field]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeField.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeFieldView: FfiConverterRustBuffer {
    typealias SwiftType = [FieldView]

    public static func write(_ value: [FieldView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeFieldView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [FieldView] {
        let len: Int32 = try readInt(&buf)
        var seq = [FieldView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeFieldView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLoginUri: FfiConverterRustBuffer {
    typealias SwiftType = [LoginUri]

    public static func write(_ value: [LoginUri], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLoginUri.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LoginUri] {
        let len: Int32 = try readInt(&buf)
        var seq = [LoginUri]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLoginUri.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeLoginUriView: FfiConverterRustBuffer {
    typealias SwiftType = [LoginUriView]

    public static func write(_ value: [LoginUriView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeLoginUriView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [LoginUriView] {
        let len: Int32 = try readInt(&buf)
        var seq = [LoginUriView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeLoginUriView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePasswordHistory: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistory]

    public static func write(_ value: [PasswordHistory], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePasswordHistory.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PasswordHistory] {
        let len: Int32 = try readInt(&buf)
        var seq = [PasswordHistory]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePasswordHistory.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypePasswordHistoryView: FfiConverterRustBuffer {
    typealias SwiftType = [PasswordHistoryView]

    public static func write(_ value: [PasswordHistoryView], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypePasswordHistoryView.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [PasswordHistoryView] {
        let len: Int32 = try readInt(&buf)
        var seq = [PasswordHistoryView]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypePasswordHistoryView.read(from: &buf))
        }
        return seq
    }
}

fileprivate struct FfiConverterSequenceTypeUuid: FfiConverterRustBuffer {
    typealias SwiftType = [Uuid]

    public static func write(_ value: [Uuid], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for item in value {
            FfiConverterTypeUuid.write(item, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Uuid] {
        let len: Int32 = try readInt(&buf)
        var seq = [Uuid]()
        seq.reserveCapacity(Int(len))
        for _ in 0 ..< len {
            seq.append(try FfiConverterTypeUuid.read(from: &buf))
        }
        return seq
    }
}








/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias LinkedIdType = UInt32
public struct FfiConverterTypeLinkedIdType: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> LinkedIdType {
        return try FfiConverterUInt32.read(from: &buf)
    }

    public static func write(_ value: LinkedIdType, into buf: inout [UInt8]) {
        return FfiConverterUInt32.write(value, into: &buf)
    }

    public static func lift(_ value: UInt32) throws -> LinkedIdType {
        return try FfiConverterUInt32.lift(value)
    }

    public static func lower(_ value: LinkedIdType) -> UInt32 {
        return FfiConverterUInt32.lower(value)
    }
}


public func FfiConverterTypeLinkedIdType_lift(_ value: UInt32) throws -> LinkedIdType {
    return try FfiConverterTypeLinkedIdType.lift(value)
}

public func FfiConverterTypeLinkedIdType_lower(_ value: LinkedIdType) -> UInt32 {
    return FfiConverterTypeLinkedIdType.lower(value)
}


private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bitwarden_vault_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all