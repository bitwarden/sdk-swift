// This file was autogenerated by some hot garbage in the `uniffi` crate.
// Trust me, you don't want to mess with it!

// swiftlint:disable all
import Foundation

// Depending on the consumer's build setup, the low-level FFI code
// might be in a separate module, or it might be compiled inline into
// this module. This is a bit of light hackery to work with both.
#if canImport(BitwardenCoreFFI)
import BitwardenCoreFFI
#endif

fileprivate extension RustBuffer {
    // Allocate a new buffer, copying the contents of a `UInt8` array.
    init(bytes: [UInt8]) {
        let rbuf = bytes.withUnsafeBufferPointer { ptr in
            RustBuffer.from(ptr)
        }
        self.init(capacity: rbuf.capacity, len: rbuf.len, data: rbuf.data)
    }

    static func empty() -> RustBuffer {
        RustBuffer(capacity: 0, len:0, data: nil)
    }

    static func from(_ ptr: UnsafeBufferPointer<UInt8>) -> RustBuffer {
        try! rustCall { ffi_bitwarden_core_rustbuffer_from_bytes(ForeignBytes(bufferPointer: ptr), $0) }
    }

    // Frees the buffer in place.
    // The buffer must not be used after this is called.
    func deallocate() {
        try! rustCall { ffi_bitwarden_core_rustbuffer_free(self, $0) }
    }
}

fileprivate extension ForeignBytes {
    init(bufferPointer: UnsafeBufferPointer<UInt8>) {
        self.init(len: Int32(bufferPointer.count), data: bufferPointer.baseAddress)
    }
}

// For every type used in the interface, we provide helper methods for conveniently
// lifting and lowering that type from C-compatible data, and for reading and writing
// values of that type in a buffer.

// Helper classes/extensions that don't change.
// Someday, this will be in a library of its own.

fileprivate extension Data {
    init(rustBuffer: RustBuffer) {
        self.init(
            bytesNoCopy: rustBuffer.data!,
            count: Int(rustBuffer.len),
            deallocator: .none
        )
    }
}

// Define reader functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.
//
// With external types, one swift source file needs to be able to call the read
// method on another source file's FfiConverter, but then what visibility
// should Reader have?
// - If Reader is fileprivate, then this means the read() must also
//   be fileprivate, which doesn't work with external types.
// - If Reader is internal/public, we'll get compile errors since both source
//   files will try define the same type.
//
// Instead, the read() method and these helper functions input a tuple of data

fileprivate func createReader(data: Data) -> (data: Data, offset: Data.Index) {
    (data: data, offset: 0)
}

// Reads an integer at the current offset, in big-endian order, and advances
// the offset on success. Throws if reading the integer would move the
// offset past the end of the buffer.
fileprivate func readInt<T: FixedWidthInteger>(_ reader: inout (data: Data, offset: Data.Index)) throws -> T {
    let range = reader.offset..<reader.offset + MemoryLayout<T>.size
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    if T.self == UInt8.self {
        let value = reader.data[reader.offset]
        reader.offset += 1
        return value as! T
    }
    var value: T = 0
    let _ = withUnsafeMutableBytes(of: &value, { reader.data.copyBytes(to: $0, from: range)})
    reader.offset = range.upperBound
    return value.bigEndian
}

// Reads an arbitrary number of bytes, to be used to read
// raw bytes, this is useful when lifting strings
fileprivate func readBytes(_ reader: inout (data: Data, offset: Data.Index), count: Int) throws -> Array<UInt8> {
    let range = reader.offset..<(reader.offset+count)
    guard reader.data.count >= range.upperBound else {
        throw UniffiInternalError.bufferOverflow
    }
    var value = [UInt8](repeating: 0, count: count)
    value.withUnsafeMutableBufferPointer({ buffer in
        reader.data.copyBytes(to: buffer, from: range)
    })
    reader.offset = range.upperBound
    return value
}

// Reads a float at the current offset.
fileprivate func readFloat(_ reader: inout (data: Data, offset: Data.Index)) throws -> Float {
    return Float(bitPattern: try readInt(&reader))
}

// Reads a float at the current offset.
fileprivate func readDouble(_ reader: inout (data: Data, offset: Data.Index)) throws -> Double {
    return Double(bitPattern: try readInt(&reader))
}

// Indicates if the offset has reached the end of the buffer.
fileprivate func hasRemaining(_ reader: (data: Data, offset: Data.Index)) -> Bool {
    return reader.offset < reader.data.count
}

// Define writer functionality.  Normally this would be defined in a class or
// struct, but we use standalone functions instead in order to make external
// types work.  See the above discussion on Readers for details.

fileprivate func createWriter() -> [UInt8] {
    return []
}

fileprivate func writeBytes<S>(_ writer: inout [UInt8], _ byteArr: S) where S: Sequence, S.Element == UInt8 {
    writer.append(contentsOf: byteArr)
}

// Writes an integer in big-endian order.
//
// Warning: make sure what you are trying to write
// is in the correct type!
fileprivate func writeInt<T: FixedWidthInteger>(_ writer: inout [UInt8], _ value: T) {
    var value = value.bigEndian
    withUnsafeBytes(of: &value) { writer.append(contentsOf: $0) }
}

fileprivate func writeFloat(_ writer: inout [UInt8], _ value: Float) {
    writeInt(&writer, value.bitPattern)
}

fileprivate func writeDouble(_ writer: inout [UInt8], _ value: Double) {
    writeInt(&writer, value.bitPattern)
}

// Protocol for types that transfer other types across the FFI. This is
// analogous to the Rust trait of the same name.
fileprivate protocol FfiConverter {
    associatedtype FfiType
    associatedtype SwiftType

    static func lift(_ value: FfiType) throws -> SwiftType
    static func lower(_ value: SwiftType) -> FfiType
    static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType
    static func write(_ value: SwiftType, into buf: inout [UInt8])
}

// Types conforming to `Primitive` pass themselves directly over the FFI.
fileprivate protocol FfiConverterPrimitive: FfiConverter where FfiType == SwiftType { }

extension FfiConverterPrimitive {
    public static func lift(_ value: FfiType) throws -> SwiftType {
        return value
    }

    public static func lower(_ value: SwiftType) -> FfiType {
        return value
    }
}

// Types conforming to `FfiConverterRustBuffer` lift and lower into a `RustBuffer`.
// Used for complex types where it's hard to write a custom lift/lower.
fileprivate protocol FfiConverterRustBuffer: FfiConverter where FfiType == RustBuffer {}

extension FfiConverterRustBuffer {
    public static func lift(_ buf: RustBuffer) throws -> SwiftType {
        var reader = createReader(data: Data(rustBuffer: buf))
        let value = try read(from: &reader)
        if hasRemaining(reader) {
            throw UniffiInternalError.incompleteData
        }
        buf.deallocate()
        return value
    }

    public static func lower(_ value: SwiftType) -> RustBuffer {
          var writer = createWriter()
          write(value, into: &writer)
          return RustBuffer(bytes: writer)
    }
}
// An error type for FFI errors. These errors occur at the UniFFI level, not
// the library level.
fileprivate enum UniffiInternalError: LocalizedError {
    case bufferOverflow
    case incompleteData
    case unexpectedOptionalTag
    case unexpectedEnumCase
    case unexpectedNullPointer
    case unexpectedRustCallStatusCode
    case unexpectedRustCallError
    case unexpectedStaleHandle
    case rustPanic(_ message: String)

    public var errorDescription: String? {
        switch self {
        case .bufferOverflow: return "Reading the requested value would read past the end of the buffer"
        case .incompleteData: return "The buffer still has data after lifting its containing value"
        case .unexpectedOptionalTag: return "Unexpected optional tag; should be 0 or 1"
        case .unexpectedEnumCase: return "Raw enum value doesn't match any cases"
        case .unexpectedNullPointer: return "Raw pointer value was null"
        case .unexpectedRustCallStatusCode: return "Unexpected RustCallStatus code"
        case .unexpectedRustCallError: return "CALL_ERROR but no errorClass specified"
        case .unexpectedStaleHandle: return "The object in the handle map has been dropped already"
        case let .rustPanic(message): return message
        }
    }
}

fileprivate extension NSLock {
    func withLock<T>(f: () throws -> T) rethrows -> T {
        self.lock()
        defer { self.unlock() }
        return try f()
    }
}

fileprivate let CALL_SUCCESS: Int8 = 0
fileprivate let CALL_ERROR: Int8 = 1
fileprivate let CALL_UNEXPECTED_ERROR: Int8 = 2
fileprivate let CALL_CANCELLED: Int8 = 3

fileprivate extension RustCallStatus {
    init() {
        self.init(
            code: CALL_SUCCESS,
            errorBuf: RustBuffer.init(
                capacity: 0,
                len: 0,
                data: nil
            )
        )
    }
}

private func rustCall<T>(_ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    let neverThrow: ((RustBuffer) throws -> Never)? = nil
    return try makeRustCall(callback, errorHandler: neverThrow)
}

private func rustCallWithError<T, E: Swift.Error>(
    _ errorHandler: @escaping (RustBuffer) throws -> E,
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T) throws -> T {
    try makeRustCall(callback, errorHandler: errorHandler)
}

private func makeRustCall<T, E: Swift.Error>(
    _ callback: (UnsafeMutablePointer<RustCallStatus>) -> T,
    errorHandler: ((RustBuffer) throws -> E)?
) throws -> T {
    uniffiEnsureInitialized()
    var callStatus = RustCallStatus.init()
    let returnedVal = callback(&callStatus)
    try uniffiCheckCallStatus(callStatus: callStatus, errorHandler: errorHandler)
    return returnedVal
}

private func uniffiCheckCallStatus<E: Swift.Error>(
    callStatus: RustCallStatus,
    errorHandler: ((RustBuffer) throws -> E)?
) throws {
    switch callStatus.code {
        case CALL_SUCCESS:
            return

        case CALL_ERROR:
            if let errorHandler = errorHandler {
                throw try errorHandler(callStatus.errorBuf)
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.unexpectedRustCallError
            }

        case CALL_UNEXPECTED_ERROR:
            // When the rust code sees a panic, it tries to construct a RustBuffer
            // with the message.  But if that code panics, then it just sends back
            // an empty buffer.
            if callStatus.errorBuf.len > 0 {
                throw UniffiInternalError.rustPanic(try FfiConverterString.lift(callStatus.errorBuf))
            } else {
                callStatus.errorBuf.deallocate()
                throw UniffiInternalError.rustPanic("Rust panic")
            }

        case CALL_CANCELLED:
            fatalError("Cancellation not supported yet")

        default:
            throw UniffiInternalError.unexpectedRustCallStatusCode
    }
}

private func uniffiTraitInterfaceCall<T>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> ()
) {
    do {
        try writeReturn(makeCall())
    } catch let error {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}

private func uniffiTraitInterfaceCallWithError<T, E>(
    callStatus: UnsafeMutablePointer<RustCallStatus>,
    makeCall: () throws -> T,
    writeReturn: (T) -> (),
    lowerError: (E) -> RustBuffer
) {
    do {
        try writeReturn(makeCall())
    } catch let error as E {
        callStatus.pointee.code = CALL_ERROR
        callStatus.pointee.errorBuf = lowerError(error)
    } catch {
        callStatus.pointee.code = CALL_UNEXPECTED_ERROR
        callStatus.pointee.errorBuf = FfiConverterString.lower(String(describing: error))
    }
}
fileprivate class UniffiHandleMap<T> {
    private var map: [UInt64: T] = [:]
    private let lock = NSLock()
    private var currentHandle: UInt64 = 1

    func insert(obj: T) -> UInt64 {
        lock.withLock {
            let handle = currentHandle
            currentHandle += 1
            map[handle] = obj
            return handle
        }
    }

     func get(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map[handle] else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    @discardableResult
    func remove(handle: UInt64) throws -> T {
        try lock.withLock {
            guard let obj = map.removeValue(forKey: handle) else {
                throw UniffiInternalError.unexpectedStaleHandle
            }
            return obj
        }
    }

    var count: Int {
        get {
            map.count
        }
    }
}


// Public interface members begin here.


fileprivate struct FfiConverterUInt8: FfiConverterPrimitive {
    typealias FfiType = UInt8
    typealias SwiftType = UInt8

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UInt8 {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: UInt8, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterBool : FfiConverter {
    typealias FfiType = Int8
    typealias SwiftType = Bool

    public static func lift(_ value: Int8) throws -> Bool {
        return value != 0
    }

    public static func lower(_ value: Bool) -> Int8 {
        return value ? 1 : 0
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Bool {
        return try lift(readInt(&buf))
    }

    public static func write(_ value: Bool, into buf: inout [UInt8]) {
        writeInt(&buf, lower(value))
    }
}

fileprivate struct FfiConverterString: FfiConverter {
    typealias SwiftType = String
    typealias FfiType = RustBuffer

    public static func lift(_ value: RustBuffer) throws -> String {
        defer {
            value.deallocate()
        }
        if value.data == nil {
            return String()
        }
        let bytes = UnsafeBufferPointer<UInt8>(start: value.data!, count: Int(value.len))
        return String(bytes: bytes, encoding: String.Encoding.utf8)!
    }

    public static func lower(_ value: String) -> RustBuffer {
        return value.utf8CString.withUnsafeBufferPointer { ptr in
            // The swift string gives us int8_t, we want uint8_t.
            ptr.withMemoryRebound(to: UInt8.self) { ptr in
                // The swift string gives us a trailing null byte, we don't want it.
                let buf = UnsafeBufferPointer(rebasing: ptr.prefix(upTo: ptr.count - 1))
                return RustBuffer.from(buf)
            }
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> String {
        let len: Int32 = try readInt(&buf)
        return String(bytes: try readBytes(&buf, count: Int(len)), encoding: String.Encoding.utf8)!
    }

    public static func write(_ value: String, into buf: inout [UInt8]) {
        let len = Int32(value.utf8.count)
        writeInt(&buf, len)
        writeBytes(&buf, value.utf8)
    }
}

fileprivate struct FfiConverterTimestamp: FfiConverterRustBuffer {
    typealias SwiftType = Date

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Date {
        let seconds: Int64 = try readInt(&buf)
        let nanoseconds: UInt32 = try readInt(&buf)
        if seconds >= 0 {
            let delta = Double(seconds) + (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        } else {
            let delta = Double(seconds) - (Double(nanoseconds) / 1.0e9)
            return Date.init(timeIntervalSince1970: delta)
        }
    }

    public static func write(_ value: Date, into buf: inout [UInt8]) {
        var delta = value.timeIntervalSince1970
        var sign: Int64 = 1
        if delta < 0 {
            // The nanoseconds portion of the epoch offset must always be
            // positive, to simplify the calculation we will use the absolute
            // value of the offset.
            sign = -1
            delta = -delta
        }
        if delta.rounded(.down) > Double(Int64.max) {
            fatalError("Timestamp overflow, exceeds max bounds supported by Uniffi")
        }
        let seconds = Int64(delta)
        let nanoseconds = UInt32((delta - Double(seconds)) * 1.0e9)
        writeInt(&buf, sign * seconds)
        writeInt(&buf, nanoseconds)
    }
}


public struct AuthRequestResponse {
    /**
     * Base64 encoded private key
     * This key is temporarily passed back and will most likely not be available in the future
     */
    public let privateKey: String
    /**
     * Base64 encoded public key
     */
    public let publicKey: String
    /**
     * Fingerprint of the public key
     */
    public let fingerprint: String
    /**
     * Access code
     */
    public let accessCode: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Base64 encoded private key
         * This key is temporarily passed back and will most likely not be available in the future
         */privateKey: String, 
        /**
         * Base64 encoded public key
         */publicKey: String, 
        /**
         * Fingerprint of the public key
         */fingerprint: String, 
        /**
         * Access code
         */accessCode: String) {
        self.privateKey = privateKey
        self.publicKey = publicKey
        self.fingerprint = fingerprint
        self.accessCode = accessCode
    }
}



extension AuthRequestResponse: Equatable, Hashable {
    public static func ==(lhs: AuthRequestResponse, rhs: AuthRequestResponse) -> Bool {
        if lhs.privateKey != rhs.privateKey {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.fingerprint != rhs.fingerprint {
            return false
        }
        if lhs.accessCode != rhs.accessCode {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(privateKey)
        hasher.combine(publicKey)
        hasher.combine(fingerprint)
        hasher.combine(accessCode)
    }
}


public struct FfiConverterTypeAuthRequestResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthRequestResponse {
        return
            try AuthRequestResponse(
                privateKey: FfiConverterString.read(from: &buf), 
                publicKey: FfiConverterString.read(from: &buf), 
                fingerprint: FfiConverterString.read(from: &buf), 
                accessCode: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: AuthRequestResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.privateKey, into: &buf)
        FfiConverterString.write(value.publicKey, into: &buf)
        FfiConverterString.write(value.fingerprint, into: &buf)
        FfiConverterString.write(value.accessCode, into: &buf)
    }
}


public func FfiConverterTypeAuthRequestResponse_lift(_ buf: RustBuffer) throws -> AuthRequestResponse {
    return try FfiConverterTypeAuthRequestResponse.lift(buf)
}

public func FfiConverterTypeAuthRequestResponse_lower(_ value: AuthRequestResponse) -> RustBuffer {
    return FfiConverterTypeAuthRequestResponse.lower(value)
}


/**
 * Basic client behavior settings. These settings specify the various targets and behavior of the
 * Bitwarden Client. They are optional and uneditable once the client is initialized.
 *
 * Defaults to
 *
 * ```
 * # use bitwarden_core::{ClientSettings, DeviceType};
 * let settings = ClientSettings {
 * identity_url: "https://identity.bitwarden.com".to_string(),
 * api_url: "https://api.bitwarden.com".to_string(),
 * user_agent: "Bitwarden Rust-SDK".to_string(),
 * device_type: DeviceType::SDK,
 * };
 * let default = ClientSettings::default();
 * ```
 */
public struct ClientSettings {
    /**
     * The identity url of the targeted Bitwarden instance. Defaults to `https://identity.bitwarden.com`
     */
    public let identityUrl: String
    /**
     * The api url of the targeted Bitwarden instance. Defaults to `https://api.bitwarden.com`
     */
    public let apiUrl: String
    /**
     * The user_agent to sent to Bitwarden. Defaults to `Bitwarden Rust-SDK`
     */
    public let userAgent: String
    /**
     * Device type to send to Bitwarden. Defaults to SDK
     */
    public let deviceType: DeviceType

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The identity url of the targeted Bitwarden instance. Defaults to `https://identity.bitwarden.com`
         */identityUrl: String, 
        /**
         * The api url of the targeted Bitwarden instance. Defaults to `https://api.bitwarden.com`
         */apiUrl: String, 
        /**
         * The user_agent to sent to Bitwarden. Defaults to `Bitwarden Rust-SDK`
         */userAgent: String, 
        /**
         * Device type to send to Bitwarden. Defaults to SDK
         */deviceType: DeviceType) {
        self.identityUrl = identityUrl
        self.apiUrl = apiUrl
        self.userAgent = userAgent
        self.deviceType = deviceType
    }
}



extension ClientSettings: Equatable, Hashable {
    public static func ==(lhs: ClientSettings, rhs: ClientSettings) -> Bool {
        if lhs.identityUrl != rhs.identityUrl {
            return false
        }
        if lhs.apiUrl != rhs.apiUrl {
            return false
        }
        if lhs.userAgent != rhs.userAgent {
            return false
        }
        if lhs.deviceType != rhs.deviceType {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(identityUrl)
        hasher.combine(apiUrl)
        hasher.combine(userAgent)
        hasher.combine(deviceType)
    }
}


public struct FfiConverterTypeClientSettings: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> ClientSettings {
        return
            try ClientSettings(
                identityUrl: FfiConverterString.read(from: &buf), 
                apiUrl: FfiConverterString.read(from: &buf), 
                userAgent: FfiConverterString.read(from: &buf), 
                deviceType: FfiConverterTypeDeviceType.read(from: &buf)
        )
    }

    public static func write(_ value: ClientSettings, into buf: inout [UInt8]) {
        FfiConverterString.write(value.identityUrl, into: &buf)
        FfiConverterString.write(value.apiUrl, into: &buf)
        FfiConverterString.write(value.userAgent, into: &buf)
        FfiConverterTypeDeviceType.write(value.deviceType, into: &buf)
    }
}


public func FfiConverterTypeClientSettings_lift(_ buf: RustBuffer) throws -> ClientSettings {
    return try FfiConverterTypeClientSettings.lift(buf)
}

public func FfiConverterTypeClientSettings_lower(_ value: ClientSettings) -> RustBuffer {
    return FfiConverterTypeClientSettings.lower(value)
}


public struct DeriveKeyConnectorRequest {
    /**
     * Encrypted user key, used to validate the master key
     */
    public let userKeyEncrypted: EncString
    public let password: String
    public let kdf: Kdf
    public let email: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Encrypted user key, used to validate the master key
         */userKeyEncrypted: EncString, password: String, kdf: Kdf, email: String) {
        self.userKeyEncrypted = userKeyEncrypted
        self.password = password
        self.kdf = kdf
        self.email = email
    }
}



extension DeriveKeyConnectorRequest: Equatable, Hashable {
    public static func ==(lhs: DeriveKeyConnectorRequest, rhs: DeriveKeyConnectorRequest) -> Bool {
        if lhs.userKeyEncrypted != rhs.userKeyEncrypted {
            return false
        }
        if lhs.password != rhs.password {
            return false
        }
        if lhs.kdf != rhs.kdf {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(userKeyEncrypted)
        hasher.combine(password)
        hasher.combine(kdf)
        hasher.combine(email)
    }
}


public struct FfiConverterTypeDeriveKeyConnectorRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeriveKeyConnectorRequest {
        return
            try DeriveKeyConnectorRequest(
                userKeyEncrypted: FfiConverterTypeEncString.read(from: &buf), 
                password: FfiConverterString.read(from: &buf), 
                kdf: FfiConverterTypeKdf.read(from: &buf), 
                email: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: DeriveKeyConnectorRequest, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.userKeyEncrypted, into: &buf)
        FfiConverterString.write(value.password, into: &buf)
        FfiConverterTypeKdf.write(value.kdf, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
    }
}


public func FfiConverterTypeDeriveKeyConnectorRequest_lift(_ buf: RustBuffer) throws -> DeriveKeyConnectorRequest {
    return try FfiConverterTypeDeriveKeyConnectorRequest.lift(buf)
}

public func FfiConverterTypeDeriveKeyConnectorRequest_lower(_ value: DeriveKeyConnectorRequest) -> RustBuffer {
    return FfiConverterTypeDeriveKeyConnectorRequest.lower(value)
}


public struct DerivePinKeyResponse {
    /**
     * [UserKey](bitwarden_crypto::UserKey) protected by PIN
     */
    public let pinProtectedUserKey: EncString
    /**
     * PIN protected by [UserKey](bitwarden_crypto::UserKey)
     */
    public let encryptedPin: EncString

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * [UserKey](bitwarden_crypto::UserKey) protected by PIN
         */pinProtectedUserKey: EncString, 
        /**
         * PIN protected by [UserKey](bitwarden_crypto::UserKey)
         */encryptedPin: EncString) {
        self.pinProtectedUserKey = pinProtectedUserKey
        self.encryptedPin = encryptedPin
    }
}



extension DerivePinKeyResponse: Equatable, Hashable {
    public static func ==(lhs: DerivePinKeyResponse, rhs: DerivePinKeyResponse) -> Bool {
        if lhs.pinProtectedUserKey != rhs.pinProtectedUserKey {
            return false
        }
        if lhs.encryptedPin != rhs.encryptedPin {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(pinProtectedUserKey)
        hasher.combine(encryptedPin)
    }
}


public struct FfiConverterTypeDerivePinKeyResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DerivePinKeyResponse {
        return
            try DerivePinKeyResponse(
                pinProtectedUserKey: FfiConverterTypeEncString.read(from: &buf), 
                encryptedPin: FfiConverterTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: DerivePinKeyResponse, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.pinProtectedUserKey, into: &buf)
        FfiConverterTypeEncString.write(value.encryptedPin, into: &buf)
    }
}


public func FfiConverterTypeDerivePinKeyResponse_lift(_ buf: RustBuffer) throws -> DerivePinKeyResponse {
    return try FfiConverterTypeDerivePinKeyResponse.lift(buf)
}

public func FfiConverterTypeDerivePinKeyResponse_lower(_ value: DerivePinKeyResponse) -> RustBuffer {
    return FfiConverterTypeDerivePinKeyResponse.lower(value)
}


public struct FingerprintRequest {
    /**
     * The input material, used in the fingerprint generation process.
     */
    public let fingerprintMaterial: String
    /**
     * The user's public key encoded with base64.
     */
    public let publicKey: String

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The input material, used in the fingerprint generation process.
         */fingerprintMaterial: String, 
        /**
         * The user's public key encoded with base64.
         */publicKey: String) {
        self.fingerprintMaterial = fingerprintMaterial
        self.publicKey = publicKey
    }
}



extension FingerprintRequest: Equatable, Hashable {
    public static func ==(lhs: FingerprintRequest, rhs: FingerprintRequest) -> Bool {
        if lhs.fingerprintMaterial != rhs.fingerprintMaterial {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(fingerprintMaterial)
        hasher.combine(publicKey)
    }
}


public struct FfiConverterTypeFingerprintRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> FingerprintRequest {
        return
            try FingerprintRequest(
                fingerprintMaterial: FfiConverterString.read(from: &buf), 
                publicKey: FfiConverterString.read(from: &buf)
        )
    }

    public static func write(_ value: FingerprintRequest, into buf: inout [UInt8]) {
        FfiConverterString.write(value.fingerprintMaterial, into: &buf)
        FfiConverterString.write(value.publicKey, into: &buf)
    }
}


public func FfiConverterTypeFingerprintRequest_lift(_ buf: RustBuffer) throws -> FingerprintRequest {
    return try FfiConverterTypeFingerprintRequest.lift(buf)
}

public func FfiConverterTypeFingerprintRequest_lower(_ value: FingerprintRequest) -> RustBuffer {
    return FfiConverterTypeFingerprintRequest.lower(value)
}


public struct InitOrgCryptoRequest {
    /**
     * The encryption keys for all the organizations the user is a part of
     */
    public let organizationKeys: [Uuid: AsymmetricEncString]

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The encryption keys for all the organizations the user is a part of
         */organizationKeys: [Uuid: AsymmetricEncString]) {
        self.organizationKeys = organizationKeys
    }
}



extension InitOrgCryptoRequest: Equatable, Hashable {
    public static func ==(lhs: InitOrgCryptoRequest, rhs: InitOrgCryptoRequest) -> Bool {
        if lhs.organizationKeys != rhs.organizationKeys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(organizationKeys)
    }
}


public struct FfiConverterTypeInitOrgCryptoRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitOrgCryptoRequest {
        return
            try InitOrgCryptoRequest(
                organizationKeys: FfiConverterDictionaryTypeUuidTypeAsymmetricEncString.read(from: &buf)
        )
    }

    public static func write(_ value: InitOrgCryptoRequest, into buf: inout [UInt8]) {
        FfiConverterDictionaryTypeUuidTypeAsymmetricEncString.write(value.organizationKeys, into: &buf)
    }
}


public func FfiConverterTypeInitOrgCryptoRequest_lift(_ buf: RustBuffer) throws -> InitOrgCryptoRequest {
    return try FfiConverterTypeInitOrgCryptoRequest.lift(buf)
}

public func FfiConverterTypeInitOrgCryptoRequest_lower(_ value: InitOrgCryptoRequest) -> RustBuffer {
    return FfiConverterTypeInitOrgCryptoRequest.lower(value)
}


public struct InitUserCryptoRequest {
    /**
     * The user's KDF parameters, as received from the prelogin request
     */
    public let kdfParams: Kdf
    /**
     * The user's email address
     */
    public let email: String
    /**
     * The user's encrypted private key
     */
    public let privateKey: String
    /**
     * The initialization method to use
     */
    public let method: InitUserCryptoMethod

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * The user's KDF parameters, as received from the prelogin request
         */kdfParams: Kdf, 
        /**
         * The user's email address
         */email: String, 
        /**
         * The user's encrypted private key
         */privateKey: String, 
        /**
         * The initialization method to use
         */method: InitUserCryptoMethod) {
        self.kdfParams = kdfParams
        self.email = email
        self.privateKey = privateKey
        self.method = method
    }
}



extension InitUserCryptoRequest: Equatable, Hashable {
    public static func ==(lhs: InitUserCryptoRequest, rhs: InitUserCryptoRequest) -> Bool {
        if lhs.kdfParams != rhs.kdfParams {
            return false
        }
        if lhs.email != rhs.email {
            return false
        }
        if lhs.privateKey != rhs.privateKey {
            return false
        }
        if lhs.method != rhs.method {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(kdfParams)
        hasher.combine(email)
        hasher.combine(privateKey)
        hasher.combine(method)
    }
}


public struct FfiConverterTypeInitUserCryptoRequest: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitUserCryptoRequest {
        return
            try InitUserCryptoRequest(
                kdfParams: FfiConverterTypeKdf.read(from: &buf), 
                email: FfiConverterString.read(from: &buf), 
                privateKey: FfiConverterString.read(from: &buf), 
                method: FfiConverterTypeInitUserCryptoMethod.read(from: &buf)
        )
    }

    public static func write(_ value: InitUserCryptoRequest, into buf: inout [UInt8]) {
        FfiConverterTypeKdf.write(value.kdfParams, into: &buf)
        FfiConverterString.write(value.email, into: &buf)
        FfiConverterString.write(value.privateKey, into: &buf)
        FfiConverterTypeInitUserCryptoMethod.write(value.method, into: &buf)
    }
}


public func FfiConverterTypeInitUserCryptoRequest_lift(_ buf: RustBuffer) throws -> InitUserCryptoRequest {
    return try FfiConverterTypeInitUserCryptoRequest.lift(buf)
}

public func FfiConverterTypeInitUserCryptoRequest_lower(_ value: InitUserCryptoRequest) -> RustBuffer {
    return FfiConverterTypeInitUserCryptoRequest.lower(value)
}


public struct KeyConnectorResponse {
    public let masterKey: String
    public let encryptedUserKey: String
    public let keys: RsaKeyPair

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(masterKey: String, encryptedUserKey: String, keys: RsaKeyPair) {
        self.masterKey = masterKey
        self.encryptedUserKey = encryptedUserKey
        self.keys = keys
    }
}



extension KeyConnectorResponse: Equatable, Hashable {
    public static func ==(lhs: KeyConnectorResponse, rhs: KeyConnectorResponse) -> Bool {
        if lhs.masterKey != rhs.masterKey {
            return false
        }
        if lhs.encryptedUserKey != rhs.encryptedUserKey {
            return false
        }
        if lhs.keys != rhs.keys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(masterKey)
        hasher.combine(encryptedUserKey)
        hasher.combine(keys)
    }
}


public struct FfiConverterTypeKeyConnectorResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> KeyConnectorResponse {
        return
            try KeyConnectorResponse(
                masterKey: FfiConverterString.read(from: &buf), 
                encryptedUserKey: FfiConverterString.read(from: &buf), 
                keys: FfiConverterTypeRsaKeyPair.read(from: &buf)
        )
    }

    public static func write(_ value: KeyConnectorResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.masterKey, into: &buf)
        FfiConverterString.write(value.encryptedUserKey, into: &buf)
        FfiConverterTypeRsaKeyPair.write(value.keys, into: &buf)
    }
}


public func FfiConverterTypeKeyConnectorResponse_lift(_ buf: RustBuffer) throws -> KeyConnectorResponse {
    return try FfiConverterTypeKeyConnectorResponse.lift(buf)
}

public func FfiConverterTypeKeyConnectorResponse_lower(_ value: KeyConnectorResponse) -> RustBuffer {
    return FfiConverterTypeKeyConnectorResponse.lower(value)
}


public struct MasterPasswordPolicyOptions {
    public let minComplexity: UInt8
    public let minLength: UInt8
    public let requireUpper: Bool
    public let requireLower: Bool
    public let requireNumbers: Bool
    public let requireSpecial: Bool
    /**
     * Flag to indicate if the policy should be enforced on login.
     * If true, and the user's password does not meet the policy requirements,
     * the user will be forced to update their password.
     */
    public let enforceOnLogin: Bool

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(minComplexity: UInt8, minLength: UInt8, requireUpper: Bool, requireLower: Bool, requireNumbers: Bool, requireSpecial: Bool, 
        /**
         * Flag to indicate if the policy should be enforced on login.
         * If true, and the user's password does not meet the policy requirements,
         * the user will be forced to update their password.
         */enforceOnLogin: Bool) {
        self.minComplexity = minComplexity
        self.minLength = minLength
        self.requireUpper = requireUpper
        self.requireLower = requireLower
        self.requireNumbers = requireNumbers
        self.requireSpecial = requireSpecial
        self.enforceOnLogin = enforceOnLogin
    }
}



extension MasterPasswordPolicyOptions: Equatable, Hashable {
    public static func ==(lhs: MasterPasswordPolicyOptions, rhs: MasterPasswordPolicyOptions) -> Bool {
        if lhs.minComplexity != rhs.minComplexity {
            return false
        }
        if lhs.minLength != rhs.minLength {
            return false
        }
        if lhs.requireUpper != rhs.requireUpper {
            return false
        }
        if lhs.requireLower != rhs.requireLower {
            return false
        }
        if lhs.requireNumbers != rhs.requireNumbers {
            return false
        }
        if lhs.requireSpecial != rhs.requireSpecial {
            return false
        }
        if lhs.enforceOnLogin != rhs.enforceOnLogin {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(minComplexity)
        hasher.combine(minLength)
        hasher.combine(requireUpper)
        hasher.combine(requireLower)
        hasher.combine(requireNumbers)
        hasher.combine(requireSpecial)
        hasher.combine(enforceOnLogin)
    }
}


public struct FfiConverterTypeMasterPasswordPolicyOptions: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> MasterPasswordPolicyOptions {
        return
            try MasterPasswordPolicyOptions(
                minComplexity: FfiConverterUInt8.read(from: &buf), 
                minLength: FfiConverterUInt8.read(from: &buf), 
                requireUpper: FfiConverterBool.read(from: &buf), 
                requireLower: FfiConverterBool.read(from: &buf), 
                requireNumbers: FfiConverterBool.read(from: &buf), 
                requireSpecial: FfiConverterBool.read(from: &buf), 
                enforceOnLogin: FfiConverterBool.read(from: &buf)
        )
    }

    public static func write(_ value: MasterPasswordPolicyOptions, into buf: inout [UInt8]) {
        FfiConverterUInt8.write(value.minComplexity, into: &buf)
        FfiConverterUInt8.write(value.minLength, into: &buf)
        FfiConverterBool.write(value.requireUpper, into: &buf)
        FfiConverterBool.write(value.requireLower, into: &buf)
        FfiConverterBool.write(value.requireNumbers, into: &buf)
        FfiConverterBool.write(value.requireSpecial, into: &buf)
        FfiConverterBool.write(value.enforceOnLogin, into: &buf)
    }
}


public func FfiConverterTypeMasterPasswordPolicyOptions_lift(_ buf: RustBuffer) throws -> MasterPasswordPolicyOptions {
    return try FfiConverterTypeMasterPasswordPolicyOptions.lift(buf)
}

public func FfiConverterTypeMasterPasswordPolicyOptions_lower(_ value: MasterPasswordPolicyOptions) -> RustBuffer {
    return FfiConverterTypeMasterPasswordPolicyOptions.lower(value)
}


public struct RegisterKeyResponse {
    public let masterPasswordHash: String
    public let encryptedUserKey: String
    public let keys: RsaKeyPair

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(masterPasswordHash: String, encryptedUserKey: String, keys: RsaKeyPair) {
        self.masterPasswordHash = masterPasswordHash
        self.encryptedUserKey = encryptedUserKey
        self.keys = keys
    }
}



extension RegisterKeyResponse: Equatable, Hashable {
    public static func ==(lhs: RegisterKeyResponse, rhs: RegisterKeyResponse) -> Bool {
        if lhs.masterPasswordHash != rhs.masterPasswordHash {
            return false
        }
        if lhs.encryptedUserKey != rhs.encryptedUserKey {
            return false
        }
        if lhs.keys != rhs.keys {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(masterPasswordHash)
        hasher.combine(encryptedUserKey)
        hasher.combine(keys)
    }
}


public struct FfiConverterTypeRegisterKeyResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RegisterKeyResponse {
        return
            try RegisterKeyResponse(
                masterPasswordHash: FfiConverterString.read(from: &buf), 
                encryptedUserKey: FfiConverterString.read(from: &buf), 
                keys: FfiConverterTypeRsaKeyPair.read(from: &buf)
        )
    }

    public static func write(_ value: RegisterKeyResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.masterPasswordHash, into: &buf)
        FfiConverterString.write(value.encryptedUserKey, into: &buf)
        FfiConverterTypeRsaKeyPair.write(value.keys, into: &buf)
    }
}


public func FfiConverterTypeRegisterKeyResponse_lift(_ buf: RustBuffer) throws -> RegisterKeyResponse {
    return try FfiConverterTypeRegisterKeyResponse.lift(buf)
}

public func FfiConverterTypeRegisterKeyResponse_lower(_ value: RegisterKeyResponse) -> RustBuffer {
    return FfiConverterTypeRegisterKeyResponse.lower(value)
}


public struct RegisterTdeKeyResponse {
    public let privateKey: EncString
    public let publicKey: String
    public let adminReset: AsymmetricEncString
    public let deviceKey: TrustDeviceResponse?

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(privateKey: EncString, publicKey: String, adminReset: AsymmetricEncString, deviceKey: TrustDeviceResponse?) {
        self.privateKey = privateKey
        self.publicKey = publicKey
        self.adminReset = adminReset
        self.deviceKey = deviceKey
    }
}



extension RegisterTdeKeyResponse: Equatable, Hashable {
    public static func ==(lhs: RegisterTdeKeyResponse, rhs: RegisterTdeKeyResponse) -> Bool {
        if lhs.privateKey != rhs.privateKey {
            return false
        }
        if lhs.publicKey != rhs.publicKey {
            return false
        }
        if lhs.adminReset != rhs.adminReset {
            return false
        }
        if lhs.deviceKey != rhs.deviceKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(privateKey)
        hasher.combine(publicKey)
        hasher.combine(adminReset)
        hasher.combine(deviceKey)
    }
}


public struct FfiConverterTypeRegisterTdeKeyResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> RegisterTdeKeyResponse {
        return
            try RegisterTdeKeyResponse(
                privateKey: FfiConverterTypeEncString.read(from: &buf), 
                publicKey: FfiConverterString.read(from: &buf), 
                adminReset: FfiConverterTypeAsymmetricEncString.read(from: &buf), 
                deviceKey: FfiConverterOptionTypeTrustDeviceResponse.read(from: &buf)
        )
    }

    public static func write(_ value: RegisterTdeKeyResponse, into buf: inout [UInt8]) {
        FfiConverterTypeEncString.write(value.privateKey, into: &buf)
        FfiConverterString.write(value.publicKey, into: &buf)
        FfiConverterTypeAsymmetricEncString.write(value.adminReset, into: &buf)
        FfiConverterOptionTypeTrustDeviceResponse.write(value.deviceKey, into: &buf)
    }
}


public func FfiConverterTypeRegisterTdeKeyResponse_lift(_ buf: RustBuffer) throws -> RegisterTdeKeyResponse {
    return try FfiConverterTypeRegisterTdeKeyResponse.lift(buf)
}

public func FfiConverterTypeRegisterTdeKeyResponse_lower(_ value: RegisterTdeKeyResponse) -> RustBuffer {
    return FfiConverterTypeRegisterTdeKeyResponse.lower(value)
}


public struct UniffiConverterDummyRecord {
    public let uuid: Uuid
    public let date: DateTime

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(uuid: Uuid, date: DateTime) {
        self.uuid = uuid
        self.date = date
    }
}



extension UniffiConverterDummyRecord: Equatable, Hashable {
    public static func ==(lhs: UniffiConverterDummyRecord, rhs: UniffiConverterDummyRecord) -> Bool {
        if lhs.uuid != rhs.uuid {
            return false
        }
        if lhs.date != rhs.date {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(uuid)
        hasher.combine(date)
    }
}


public struct FfiConverterTypeUniffiConverterDummyRecord: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UniffiConverterDummyRecord {
        return
            try UniffiConverterDummyRecord(
                uuid: FfiConverterTypeUuid.read(from: &buf), 
                date: FfiConverterTypeDateTime.read(from: &buf)
        )
    }

    public static func write(_ value: UniffiConverterDummyRecord, into buf: inout [UInt8]) {
        FfiConverterTypeUuid.write(value.uuid, into: &buf)
        FfiConverterTypeDateTime.write(value.date, into: &buf)
    }
}


public func FfiConverterTypeUniffiConverterDummyRecord_lift(_ buf: RustBuffer) throws -> UniffiConverterDummyRecord {
    return try FfiConverterTypeUniffiConverterDummyRecord.lift(buf)
}

public func FfiConverterTypeUniffiConverterDummyRecord_lower(_ value: UniffiConverterDummyRecord) -> RustBuffer {
    return FfiConverterTypeUniffiConverterDummyRecord.lower(value)
}


public struct UpdatePasswordResponse {
    /**
     * Hash of the new password
     */
    public let passwordHash: String
    /**
     * User key, encrypted with the new password
     */
    public let newKey: EncString

    // Default memberwise initializers are never public by default, so we
    // declare one manually.
    public init(
        /**
         * Hash of the new password
         */passwordHash: String, 
        /**
         * User key, encrypted with the new password
         */newKey: EncString) {
        self.passwordHash = passwordHash
        self.newKey = newKey
    }
}



extension UpdatePasswordResponse: Equatable, Hashable {
    public static func ==(lhs: UpdatePasswordResponse, rhs: UpdatePasswordResponse) -> Bool {
        if lhs.passwordHash != rhs.passwordHash {
            return false
        }
        if lhs.newKey != rhs.newKey {
            return false
        }
        return true
    }

    public func hash(into hasher: inout Hasher) {
        hasher.combine(passwordHash)
        hasher.combine(newKey)
    }
}


public struct FfiConverterTypeUpdatePasswordResponse: FfiConverterRustBuffer {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> UpdatePasswordResponse {
        return
            try UpdatePasswordResponse(
                passwordHash: FfiConverterString.read(from: &buf), 
                newKey: FfiConverterTypeEncString.read(from: &buf)
        )
    }

    public static func write(_ value: UpdatePasswordResponse, into buf: inout [UInt8]) {
        FfiConverterString.write(value.passwordHash, into: &buf)
        FfiConverterTypeEncString.write(value.newKey, into: &buf)
    }
}


public func FfiConverterTypeUpdatePasswordResponse_lift(_ buf: RustBuffer) throws -> UpdatePasswordResponse {
    return try FfiConverterTypeUpdatePasswordResponse.lift(buf)
}

public func FfiConverterTypeUpdatePasswordResponse_lower(_ value: UpdatePasswordResponse) -> RustBuffer {
    return FfiConverterTypeUpdatePasswordResponse.lower(value)
}

// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum AuthRequestMethod {
    
    case userKey(
        /**
         * User Key protected by the private key provided in `AuthRequestResponse`.
         */protectedUserKey: AsymmetricEncString
    )
    case masterKey(
        /**
         * Master Key protected by the private key provided in `AuthRequestResponse`.
         */protectedMasterKey: AsymmetricEncString, 
        /**
         * User Key protected by the MasterKey, provided by the auth response.
         */authRequestKey: EncString
    )
}


public struct FfiConverterTypeAuthRequestMethod: FfiConverterRustBuffer {
    typealias SwiftType = AuthRequestMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> AuthRequestMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .userKey(protectedUserKey: try FfiConverterTypeAsymmetricEncString.read(from: &buf)
        )
        
        case 2: return .masterKey(protectedMasterKey: try FfiConverterTypeAsymmetricEncString.read(from: &buf), authRequestKey: try FfiConverterTypeEncString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: AuthRequestMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .userKey(protectedUserKey):
            writeInt(&buf, Int32(1))
            FfiConverterTypeAsymmetricEncString.write(protectedUserKey, into: &buf)
            
        
        case let .masterKey(protectedMasterKey,authRequestKey):
            writeInt(&buf, Int32(2))
            FfiConverterTypeAsymmetricEncString.write(protectedMasterKey, into: &buf)
            FfiConverterTypeEncString.write(authRequestKey, into: &buf)
            
        }
    }
}


public func FfiConverterTypeAuthRequestMethod_lift(_ buf: RustBuffer) throws -> AuthRequestMethod {
    return try FfiConverterTypeAuthRequestMethod.lift(buf)
}

public func FfiConverterTypeAuthRequestMethod_lower(_ value: AuthRequestMethod) -> RustBuffer {
    return FfiConverterTypeAuthRequestMethod.lower(value)
}



extension AuthRequestMethod: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum DeviceType {
    
    case android
    case iOs
    case chromeExtension
    case firefoxExtension
    case operaExtension
    case edgeExtension
    case windowsDesktop
    case macOsDesktop
    case linuxDesktop
    case chromeBrowser
    case firefoxBrowser
    case operaBrowser
    case edgeBrowser
    case ieBrowser
    case unknownBrowser
    case androidAmazon
    case uwp
    case safariBrowser
    case vivaldiBrowser
    case vivaldiExtension
    case safariExtension
    case sdk
    case server
    case windowsCli
    case macOsCli
    case linuxCli
}


public struct FfiConverterTypeDeviceType: FfiConverterRustBuffer {
    typealias SwiftType = DeviceType

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DeviceType {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .android
        
        case 2: return .iOs
        
        case 3: return .chromeExtension
        
        case 4: return .firefoxExtension
        
        case 5: return .operaExtension
        
        case 6: return .edgeExtension
        
        case 7: return .windowsDesktop
        
        case 8: return .macOsDesktop
        
        case 9: return .linuxDesktop
        
        case 10: return .chromeBrowser
        
        case 11: return .firefoxBrowser
        
        case 12: return .operaBrowser
        
        case 13: return .edgeBrowser
        
        case 14: return .ieBrowser
        
        case 15: return .unknownBrowser
        
        case 16: return .androidAmazon
        
        case 17: return .uwp
        
        case 18: return .safariBrowser
        
        case 19: return .vivaldiBrowser
        
        case 20: return .vivaldiExtension
        
        case 21: return .safariExtension
        
        case 22: return .sdk
        
        case 23: return .server
        
        case 24: return .windowsCli
        
        case 25: return .macOsCli
        
        case 26: return .linuxCli
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: DeviceType, into buf: inout [UInt8]) {
        switch value {
        
        
        case .android:
            writeInt(&buf, Int32(1))
        
        
        case .iOs:
            writeInt(&buf, Int32(2))
        
        
        case .chromeExtension:
            writeInt(&buf, Int32(3))
        
        
        case .firefoxExtension:
            writeInt(&buf, Int32(4))
        
        
        case .operaExtension:
            writeInt(&buf, Int32(5))
        
        
        case .edgeExtension:
            writeInt(&buf, Int32(6))
        
        
        case .windowsDesktop:
            writeInt(&buf, Int32(7))
        
        
        case .macOsDesktop:
            writeInt(&buf, Int32(8))
        
        
        case .linuxDesktop:
            writeInt(&buf, Int32(9))
        
        
        case .chromeBrowser:
            writeInt(&buf, Int32(10))
        
        
        case .firefoxBrowser:
            writeInt(&buf, Int32(11))
        
        
        case .operaBrowser:
            writeInt(&buf, Int32(12))
        
        
        case .edgeBrowser:
            writeInt(&buf, Int32(13))
        
        
        case .ieBrowser:
            writeInt(&buf, Int32(14))
        
        
        case .unknownBrowser:
            writeInt(&buf, Int32(15))
        
        
        case .androidAmazon:
            writeInt(&buf, Int32(16))
        
        
        case .uwp:
            writeInt(&buf, Int32(17))
        
        
        case .safariBrowser:
            writeInt(&buf, Int32(18))
        
        
        case .vivaldiBrowser:
            writeInt(&buf, Int32(19))
        
        
        case .vivaldiExtension:
            writeInt(&buf, Int32(20))
        
        
        case .safariExtension:
            writeInt(&buf, Int32(21))
        
        
        case .sdk:
            writeInt(&buf, Int32(22))
        
        
        case .server:
            writeInt(&buf, Int32(23))
        
        
        case .windowsCli:
            writeInt(&buf, Int32(24))
        
        
        case .macOsCli:
            writeInt(&buf, Int32(25))
        
        
        case .linuxCli:
            writeInt(&buf, Int32(26))
        
        }
    }
}


public func FfiConverterTypeDeviceType_lift(_ buf: RustBuffer) throws -> DeviceType {
    return try FfiConverterTypeDeviceType.lift(buf)
}

public func FfiConverterTypeDeviceType_lower(_ value: DeviceType) -> RustBuffer {
    return FfiConverterTypeDeviceType.lower(value)
}



extension DeviceType: Equatable, Hashable {}



// Note that we don't yet support `indirect` for enums.
// See https://github.com/mozilla/uniffi-rs/issues/396 for further discussion.

public enum InitUserCryptoMethod {
    
    case password(
        /**
         * The user's master password
         */password: String, 
        /**
         * The user's encrypted symmetric crypto key
         */userKey: String
    )
    case decryptedKey(
        /**
         * The user's decrypted encryption key, obtained using `get_user_encryption_key`
         */decryptedUserKey: String
    )
    case pin(
        /**
         * The user's PIN
         */pin: String, 
        /**
         * The user's symmetric crypto key, encrypted with the PIN. Use `derive_pin_key` to obtain
         * this.
         */pinProtectedUserKey: EncString
    )
    case authRequest(
        /**
         * Private Key generated by the `crate::auth::new_auth_request`.
         */requestPrivateKey: String, method: AuthRequestMethod
    )
    case deviceKey(
        /**
         * The device's DeviceKey
         */deviceKey: String, 
        /**
         * The Device Private Key
         */protectedDevicePrivateKey: EncString, 
        /**
         * The user's symmetric crypto key, encrypted with the Device Key.
         */deviceProtectedUserKey: AsymmetricEncString
    )
    case keyConnector(
        /**
         * Base64 encoded master key, retrieved from the key connector.
         */masterKey: String, 
        /**
         * The user's encrypted symmetric crypto key
         */userKey: String
    )
}


public struct FfiConverterTypeInitUserCryptoMethod: FfiConverterRustBuffer {
    typealias SwiftType = InitUserCryptoMethod

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> InitUserCryptoMethod {
        let variant: Int32 = try readInt(&buf)
        switch variant {
        
        case 1: return .password(password: try FfiConverterString.read(from: &buf), userKey: try FfiConverterString.read(from: &buf)
        )
        
        case 2: return .decryptedKey(decryptedUserKey: try FfiConverterString.read(from: &buf)
        )
        
        case 3: return .pin(pin: try FfiConverterString.read(from: &buf), pinProtectedUserKey: try FfiConverterTypeEncString.read(from: &buf)
        )
        
        case 4: return .authRequest(requestPrivateKey: try FfiConverterString.read(from: &buf), method: try FfiConverterTypeAuthRequestMethod.read(from: &buf)
        )
        
        case 5: return .deviceKey(deviceKey: try FfiConverterString.read(from: &buf), protectedDevicePrivateKey: try FfiConverterTypeEncString.read(from: &buf), deviceProtectedUserKey: try FfiConverterTypeAsymmetricEncString.read(from: &buf)
        )
        
        case 6: return .keyConnector(masterKey: try FfiConverterString.read(from: &buf), userKey: try FfiConverterString.read(from: &buf)
        )
        
        default: throw UniffiInternalError.unexpectedEnumCase
        }
    }

    public static func write(_ value: InitUserCryptoMethod, into buf: inout [UInt8]) {
        switch value {
        
        
        case let .password(password,userKey):
            writeInt(&buf, Int32(1))
            FfiConverterString.write(password, into: &buf)
            FfiConverterString.write(userKey, into: &buf)
            
        
        case let .decryptedKey(decryptedUserKey):
            writeInt(&buf, Int32(2))
            FfiConverterString.write(decryptedUserKey, into: &buf)
            
        
        case let .pin(pin,pinProtectedUserKey):
            writeInt(&buf, Int32(3))
            FfiConverterString.write(pin, into: &buf)
            FfiConverterTypeEncString.write(pinProtectedUserKey, into: &buf)
            
        
        case let .authRequest(requestPrivateKey,method):
            writeInt(&buf, Int32(4))
            FfiConverterString.write(requestPrivateKey, into: &buf)
            FfiConverterTypeAuthRequestMethod.write(method, into: &buf)
            
        
        case let .deviceKey(deviceKey,protectedDevicePrivateKey,deviceProtectedUserKey):
            writeInt(&buf, Int32(5))
            FfiConverterString.write(deviceKey, into: &buf)
            FfiConverterTypeEncString.write(protectedDevicePrivateKey, into: &buf)
            FfiConverterTypeAsymmetricEncString.write(deviceProtectedUserKey, into: &buf)
            
        
        case let .keyConnector(masterKey,userKey):
            writeInt(&buf, Int32(6))
            FfiConverterString.write(masterKey, into: &buf)
            FfiConverterString.write(userKey, into: &buf)
            
        }
    }
}


public func FfiConverterTypeInitUserCryptoMethod_lift(_ buf: RustBuffer) throws -> InitUserCryptoMethod {
    return try FfiConverterTypeInitUserCryptoMethod.lift(buf)
}

public func FfiConverterTypeInitUserCryptoMethod_lower(_ value: InitUserCryptoMethod) -> RustBuffer {
    return FfiConverterTypeInitUserCryptoMethod.lower(value)
}



extension InitUserCryptoMethod: Equatable, Hashable {}



fileprivate struct FfiConverterOptionTypeTrustDeviceResponse: FfiConverterRustBuffer {
    typealias SwiftType = TrustDeviceResponse?

    public static func write(_ value: SwiftType, into buf: inout [UInt8]) {
        guard let value = value else {
            writeInt(&buf, Int8(0))
            return
        }
        writeInt(&buf, Int8(1))
        FfiConverterTypeTrustDeviceResponse.write(value, into: &buf)
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> SwiftType {
        switch try readInt(&buf) as Int8 {
        case 0: return nil
        case 1: return try FfiConverterTypeTrustDeviceResponse.read(from: &buf)
        default: throw UniffiInternalError.unexpectedOptionalTag
        }
    }
}

fileprivate struct FfiConverterDictionaryTypeUuidTypeAsymmetricEncString: FfiConverterRustBuffer {
    public static func write(_ value: [Uuid: AsymmetricEncString], into buf: inout [UInt8]) {
        let len = Int32(value.count)
        writeInt(&buf, len)
        for (key, value) in value {
            FfiConverterTypeUuid.write(key, into: &buf)
            FfiConverterTypeAsymmetricEncString.write(value, into: &buf)
        }
    }

    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> [Uuid: AsymmetricEncString] {
        let len: Int32 = try readInt(&buf)
        var dict = [Uuid: AsymmetricEncString]()
        dict.reserveCapacity(Int(len))
        for _ in 0..<len {
            let key = try FfiConverterTypeUuid.read(from: &buf)
            let value = try FfiConverterTypeAsymmetricEncString.read(from: &buf)
            dict[key] = value
        }
        return dict
    }
}












/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias DateTime = Date
public struct FfiConverterTypeDateTime: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> DateTime {
        return try FfiConverterTimestamp.read(from: &buf)
    }

    public static func write(_ value: DateTime, into buf: inout [UInt8]) {
        return FfiConverterTimestamp.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> DateTime {
        return try FfiConverterTimestamp.lift(value)
    }

    public static func lower(_ value: DateTime) -> RustBuffer {
        return FfiConverterTimestamp.lower(value)
    }
}


public func FfiConverterTypeDateTime_lift(_ value: RustBuffer) throws -> DateTime {
    return try FfiConverterTypeDateTime.lift(value)
}

public func FfiConverterTypeDateTime_lower(_ value: DateTime) -> RustBuffer {
    return FfiConverterTypeDateTime.lower(value)
}



/**
 * Typealias from the type name used in the UDL file to the builtin type.  This
 * is needed because the UDL type name is used in function/method signatures.
 */
public typealias Uuid = String
public struct FfiConverterTypeUuid: FfiConverter {
    public static func read(from buf: inout (data: Data, offset: Data.Index)) throws -> Uuid {
        return try FfiConverterString.read(from: &buf)
    }

    public static func write(_ value: Uuid, into buf: inout [UInt8]) {
        return FfiConverterString.write(value, into: &buf)
    }

    public static func lift(_ value: RustBuffer) throws -> Uuid {
        return try FfiConverterString.lift(value)
    }

    public static func lower(_ value: Uuid) -> RustBuffer {
        return FfiConverterString.lower(value)
    }
}


public func FfiConverterTypeUuid_lift(_ value: RustBuffer) throws -> Uuid {
    return try FfiConverterTypeUuid.lift(value)
}

public func FfiConverterTypeUuid_lower(_ value: Uuid) -> RustBuffer {
    return FfiConverterTypeUuid.lower(value)
}


private enum InitializationResult {
    case ok
    case contractVersionMismatch
    case apiChecksumMismatch
}
// Use a global variable to perform the versioning checks. Swift ensures that
// the code inside is only computed once.
private var initializationResult: InitializationResult = {
    // Get the bindings contract version from our ComponentInterface
    let bindings_contract_version = 26
    // Get the scaffolding contract version by calling the into the dylib
    let scaffolding_contract_version = ffi_bitwarden_core_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version {
        return InitializationResult.contractVersionMismatch
    }

    return InitializationResult.ok
}()

private func uniffiEnsureInitialized() {
    switch initializationResult {
    case .ok:
        break
    case .contractVersionMismatch:
        fatalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")
    case .apiChecksumMismatch:
        fatalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    }
}

// swiftlint:enable all